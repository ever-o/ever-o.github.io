[{"title":"CSS学习笔记","date":"2022-09-29T12:12:12.000Z","url":"/2022/09/29/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["CSS","/tags/CSS/"]],"categories":[["undefined",""]],"content":"1. CSS布局1.1 弹性盒子布局 弹性盒子有弹性容器 + 弹性子元素组成，通过设置弹性容器的display=flex定义 注意： 弹性盒子只定义了弹性子元素在弹性容器内如何布局，不影响子元素内部表现 容器默认只有一行，元素默认从左往右布局 如果在既定宽度的情况下，元素即将超出一行，弹性容器会压缩弹性子元素的宽度，如 1.1.1 弹性容器CSS属性flex-direction 元素怎么排flex-direction：对齐方向 作用：flex-direction指定了弹性子元素在弹性容器中的位置（横着排还是竖着排？正着排还是反着排？） 语法：flex-direction: row | row-reverse | column | column-reverse flex-direction的值有: row：横向从左到右排列（左对齐），默认的排列方式。 row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。 column：纵向排列。 column-reverse：反转纵向排列，从后往前排，最后一项排在最上面。 justify-content 元素怎么对齐justify-content：内容对齐， 作用：将弹性子元素沿着弹性容器的主轴线对齐 各个值解析: flex-start：靠着开头 弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。 flex-end：靠着末尾 弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。 center：居中 弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。 space-between：开头末尾顶在边边，中间的均匀排列 弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。 space-around：从开头开始均匀排列 弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1&#x2F;2*20px&#x3D;10px）。 align-items 侧轴位置align-items设置弹性元素在弹性容器侧轴的对其方式 align-items: flex-start | flex-end | center | baseline | stretch 各个值解析: flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。 flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。 center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。 baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。 stretch：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min&#x2F;max-width&#x2F;height’属性的限制。 flex-wrap 是否换行flex-wrap 属性用于指定弹性盒子的子元素换行方式。 flex-wrap: nowrap|wrap|wrap-reverse|initial|inherit; 各个值解析: nowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。 wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行 wrap-reverse -反转 wrap 排列。 1.1.2 弹性元素CSS属性order 排序用整数值来定义排列顺序，数值小的排在前面。可以为负值。默认值为0 margin 居中将margin设置为auto，可以将margin自动设置为弹性容器中剩下的所有空间，如 这边就将右边距设置为了弹性容器下的所有剩余空间应该就是这一快： 使得其他元素都被挤到右边去了 子元素margin设置为auto可以实现完美居中 align-self 对齐方式弹性容器的align-items是设置弹性容器中所有子元素的侧轴对齐方式（如果是横着排的那么侧重就是纵轴），那么子元素的align-self就是当前子元素的侧轴对齐方式，二者相比，align-self优先 align-self: auto | flex-start | flex-end | center | baseline | stretch 各个值解析: auto：如果’align-self’的值为’auto’，则其计算值为元素的父元素的’align-items’值，如果其没有父元素，则计算值为’stretch’。 flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。 flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。 center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。 baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。 stretch：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min&#x2F;max-width&#x2F;height’属性的限制。 flex 权重flex 指定弹性元素如何分配空间，如： 1.1.3 实践实现下图布局： "},{"title":"JavaScript学习","date":"2022-09-23T10:27:04.000Z","url":"/2022/09/23/JavaScript%E5%AD%A6%E4%B9%A0/","categories":[["undefined",""]],"content":"一. 语言基础1. 变量 var 作用域：函数级 可进行变量提升 允许冗余声明 在全局中声明会作为 window 对象的属性 let 作用域：块作用域 不可变量提升 不允许冗余声明 全局声明不会作为window的属性 const 声明的变量必须同时初始化，其他与let的用法相同 如果const声明的变量时引用类型，只需要保证引用类型的值不变，引用类型指向的对象可以改变 变量使用规范 const &gt; let 不适用var 2. 数据类型基础数据类型：Undefined、Null、Boolen、Number、String、Symbol，Object 2.1 typeof操作符 typeof typeof是一个操作符，不是函数，但是可以传递参数 用法：typeof null // object typeof null 返回的是object对象而不是null。因为null 被认为是一个对空对象的引用 2.2 Undefined、Null、Boolean Undefined Undefined类型只有一个值，undefined 当var，let声明变量但是未指定初始值时，其值就是undefined 变量未声明，直接typeof该变量时，返回的也是undefined 因此建议变量声明时就初始化，这样当控制台输出undefined时，就可以确认这个变量是未声明的 Null Null类型只有一个值，null，表示一个空对象和的指针 如果声明的变量将来要保存对象的值，建议初始化为null（不然不初始化的话就是undefined，和对象以外的数据类型混淆） undefined是由null衍生而来，因此这段代码返回 true undefined == null Boolean 两个值 在控制流语句的时候，会自动执行其他类型值到boolen值的转化 2.3 NumberNumber类型包括整数和浮点数类型 0开头表示八进制，0x开头表示16进制 浮点数的存储压力大，能转化为整数的都会转化 不要测定某个浮点数的值！如 0.1 + 0.2 == 0.3 // false NaN：返回数值的操作失败了，不会抛出错误，会返回NaN，一个特殊的Number值 任何数除于0，NaN参与的运算，都会返回NaN 可以通过isNaN方法判断当前数据是否为NaN 正常数据，可转化为数据的字符串，布尔值等都不是NaN 数值转化方法：Number() parseInt() parseFloat Number()：将其他类型数据转化为数值 parseInt()：转化为整数 第一个参数是带转化参数 转化规则需要则查阅 第二个参数可选，表示转化进制 2.4 String2.4.1 字符串基本 带斜杠的表示转义字符，可以表示一些字符字面量，转义字符在计算长度时一般计算为1 字符串不可变。要修改只能删了再建 字符串转化方法：toString() String() null，undefined没有toString方法，要转化只能通过String(null)之类 数字使用toString方法时，参数为转化进制，如 let a=16; a.tostring(16); // &#39;a&#39; 2.4.2 模板字面量 语法：`…（内容）&#96; 作用 可以直接在字符串内部换行，效果和 \\n 一样 可以使用字符串插值：$&#123;变量名&#125;，在字符串内调用外面变量，如 从而避免一步步拼接字符串 可以使用标签函数 2.5 SymbolES6新增类型，用于创建唯一记号，进而用作非字符串形式的对象属性 2.6 Objectlet o = new Object(); 3. 操作符 位操作符 与，或，非，异或 关系操作符 &lt; , &gt; , &lt;= , &gt;= , 比较字符串与字符串时，会比较字符串的ASCII编码，可以进行排序 在比较数字与字符串时，会先将字符串转化为数字再进行比较，如果字符串转化后为NaN则返回false（NaN和任何数字比较都返回false） 逗号操作符： let num1 = 1, num2 = 2, num3 = 3; let num = (5, 1, 4, 8, 0); // num 的值为 0 3.1 等于操作符 等于操作符分为 等于 不等于，全等 不全等 两类四种 等于和不等于== ！= 在比较前会做强制类型转化 布尔值，字符串会转化成数字再和数值比较 对象和不是对象的操作数比较，会先调用对象的valueof方法取得原始值；如果两个都是对象操作数，则比较二者是否指向同一个对象 null &#x3D;&#x3D; undefined ，且二者不能转化为其他类型的值再进行比较，即其他值都不等于 null 或 undefined NaN 不等于 任何操作数，包括NaN 全等和不全等=== ！== 不做强制类型转化 null !&#x3D;&#x3D; undefined 4. 语句 标签语句，给语句加标签。语法： label: statement ，例子 start是一个标签，可以再后面通过break和continue语句引用，如 其会直接中断外层循环并跳出，不用自己再设置boolen值进行判断 with语句：将代码作用域设置为特定的对象。 语法with (expression) statement;，例子 with语句会影响和性能，不推荐使用 二. 变量、作用域、内存1. 原始值与引用值原始值指的就是Undefined、Null、Boolen、Number、String、Symbol这六个类型的值，保存原始值的变量存的就是这些值本身，是按值访问的，我们操作变量实际上就是操作这些值。引用值就是保存在内存中的对象，JavaScript中不能直接操作内存空间，保存引用值的变量存的是对象的地址，是按引用访问的。 不同点 引用值可以设置对象属性，原始值不行 二者复制方式不同 原始值是直接将值复制到新变量上（栈上），二者独立使用不干扰 引用值则复制的是引用，二者指向同一个堆上对象 传递参数 JavaScript函数传参是按值传递 如果是按引用传递的话，输出的应该是Greg；安置传递导致obj再函数内新建的对象，在执行完函数后自动销毁 原始值直接复制一份进去，不会对外面产生影响 引用值同样也是复制一份进去，但是由于指向的是同一个对象，所以可能会对外面产生影响 2. 上下文与作用域 每个上下文都有一个关联的变量对象（variable object）， 而这个上下文中定义的所有变量和函数都存在于这个对象上 简单来说，就是当前函数只能访问得到自己定义的变量以及他的父级函数以及父级的父级… 的变量，这些作用域形成一条作用域链，离当前函数越近排得越靠前。每当有需要查找的标识符时，就按照作用域链依次查找 作用域链增强：将某个作用域提升到作用域链的最前端 with语句 try&#x2F;catch中的catch语句 3. 垃圾回收 ⭐ 目的：管理内存，释放不必要的内存占用，提高利用率 基本思路：确定哪个变量不会再用，释放它的内存；周期性进行 实现方法：垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存 标记未使用的变量的两种策略：标记清理、引用计数 3.1 清理策略3.1.1 标记清理 步骤 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种） 然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉（因为这些变量都可能被调用） 在这之后标记还存在的变量就是待删除的，垃圾回收程序会做一次内存清理，销毁带标记的值并收回内存 效果 最常用的垃圾回收策略，周期性进行 脱离作用域的变量会被回收 3.1.2 引用计数 方法： 当一个值（内存空间）的引用数为0时，下次进行垃圾回收的时候会将其回收。 引用数计算方式：声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。 问题 循环引用 在这个例子中，objectA 和 objectB 通过各自的属性相互引用，意味着它们的引用数都是 2。在标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，objectA 和 objectB 在函数结束后还会存在，因为它们的引用数永远不会变成 0。如果函数被多次调用，则会导致大量内存永远不会被释放。 循环引用解决方式：在确定不使用的情况下，将引用变量设置为null 3.2 内存管理将内存占用量保持在一个较低的值可以让页面的性能更好，而优化内存占用的最佳手段就是只保存执行过程中的必要数据；如果不再必要，则设置为null （使得原先的值不再存在于上下文或者上下文变量的引用中），在下次垃圾回收时候被回收 如果时函数级变量，在函数执行完成后，变量值会自动脱离上下文，不用专门设置变量为null 设置为null的场景更多在于全局变量，因为其脱离上下文得等到整个程序结束 3.2.1 const 与 let 改善性能因为 const和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生。 3.2.2 隐藏类与删除操作V8 Javascript引擎在将代码编译为机器码时，会使用“隐藏类”，共用隐藏类有助于性能提升 创建对象 在创建实例对象时，实例对象会共用隐藏类，如 但是如果之后再实例的基础上进行动态属性复制，二者隐藏类将无法共享而是各自独有，而依据操作的频率以及隐藏类的大小会对性能造成不同程度的影响，如 解决方法：避免先创建再补充的动态属性复制，在构造函数中一次性声明所有属性 删除属性 删除(delete)属性会影响隐藏类共享 上述代码两个实例不再共享隐藏类，而解决方法是不要使用delete，而是直接将不需要的属性设置为null，这样不影响隐藏类共享，而且可以协助垃圾回收的进行 3.2.3 内存泄漏内存泄漏：内存空间持续暴露，无法回收 意外声明全局变量 此时，解释器会把变量 name 当作 window 的属性来创建（相当于 window.name &#x3D; ‘Jake’）。可想而知，在 window 对象上创建的属性，只要 window 本身不被清理就不会消失。解决方法，只要在变量声明前头加上 var、let 或 const 关键字即可，这样变量就会在函数执行完毕后离开作用域。 定时器导致内存泄漏 定时器一直允许，name就无法回收 闭包导致内存泄漏 上述函数中返回的函数引用到了原来函数内部的name变量，只要返回的函数还存在着，原来的函数中的name变量就始终无法回收 3.2.4 静态分配与对象池由于垃圾回收会降低浏览器性能，我们在想办法让垃圾回收的效率提高的同时，也需要想办法尽可能地减少垃圾回收的发生；理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。 浏览器决定何时运行垃圾回收运行的一个标准是对象的更替速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行。例如 如果频繁调用这个方法的话，就会不断由Vector对象的创建和脱离作用域，导致垃圾回收更快发生，解决办法就是不要在内部创建对象而是使用外面已经存在的对象 外面的对象在哪里创建呢？一个策略是使用对象池，即其本身持有一定数量的对象实例，需要使用则从中取出一个实例，不需要则归还，因为对象池中的对象始终存在，所以垃圾回收探测不会发现有对象频繁更替，减少运行频率 三、基本引用类型引用值（或者对象）是某个特定引用类型的实例，引用类型是将数据和功能组织到一起的结构，也被称为对象定义，但是它不等同于类。ECMAScript中也缺少面向对象编程语言的基本结构，包括类和接口。 注意：函数也是一种引用类型，也可以创建对应对象 1. Data1.1 创建Data对象Data是一种引用类型，可以创建Data的实例对象，创建方法如下 Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。支持的日期格式如下 Date.UTC()方法也返回日期的毫秒表示的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。例子如下 1.2 继承的方法toLocaleString()、toString()和 valueOf() toLocaleString()：返回与浏览器运行的本地环境一致的日期 toString()：：通常返回带时区信息的日期和时间 valueOf()：根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示 1.3 日期格式化方法 一些其他的接口需要则自行查阅 2. RegExp 具体语法需要用时再查 3. 原始值的包装类由于原始值包装类型的存在，JavaScript 中的原始值可以被当成对象来使用。有 3 种原始值包装类型：Boolean、Number 和 String。它们都具备如下特点。 每种包装类型都映射到同名的原始类型。 以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。（比如可以调用对应方法） 涉及原始值的语句执行完毕后，包装对象就会被销毁。 4. 内置单例当代码开始执行时，全局上下文中会存在两个内置对象：Global 和 Math。其中，Global 对象在大多数 ECMAScript 实现中无法直接访问。不过，浏览器将其实现为 window 对象。所有全局变量和函数都是 Global 对象的属性。Math 对象包含辅助完成复杂计算的属性和方法。 四、集合引用类型1. Object 创建方式 new Object()，之后动态赋值属性 以对象字面量的形式创建（不会调用Object的构造函数） 属性存取方式 点语法，即 Person.name之类（首选） 中括号，如Preson[“name”]，如果是字符串要加引号 其用处主要在于中括号内部可以使用变量，以及在点语法不合法的情况下 2. Array2.1 创建数组 new Array() 可以不传参，可以传长度，可以传数组元素 new可以省略 数组字面量，如 let arr1 = [1,2,3,4] 同Object，不会调用构造函数 Array.form(param1) 用于将类数组结构转化为数组实例 第一个参数是一个可迭代对象，或者是有一个length属性和可索引元素的结构 第二个可选参数：一个映射函数 第三个可选参数：指定映射函数中this的值 Array.of(param) 将一组参数转化为数组 如：Array.of(…[1,2,3,4]) // [1,2,3,4] 2.2 数组空位 创建数组的时候可以只输入逗号不输入具体值，其会创建对应长度，并且每个元素的值都是undefined的数组 ES6后，空位的值是undefined；ES6之前则不一定 所以建议如果要创建有空位的数组的话，将空位设置为undefined 2.3 数组索引 可以通过索引来访问数组元素 可以通过索引来新增数组元素 如果索引超出长度，则中间未定义的元素值为undefined 可以直接设置数组的length属性，来新增数组元素（值都为undefined） 可以通过length属性，方便地向数组末尾添加元素 2.4 检测数组 instanceof Array.isArray 2.5 迭代器方法 keys() values() entries()是数组上的三个检索数组内容的方法， 第一个返回数组索引的迭代器 第二个返回数组值的迭代器 第三个返回数组 索引&#x2F;值对 的迭代器 可以通过form方法，把迭代器转化为数组 可以通过 for-of 循环，遍历迭代器 for-of循环是只能遍历迭代器，其寻找下一个的方式是通过迭代器的next()方法 2.6 复制和填充 批量复制方法fill()和填充数组方法copyWithin() fill(value,beginIndex,endIndex) 作用：向一个数组中插入全部或部分相同的值 第一个参数；是填充的数值 beginIndex：开始填充的位置，可选，默认从头 endIndex：填充到哪里，可选，默认到末尾 其中index如果是负数，则表示从末尾开始，可通过加上数组长度来计算实际位置 如果index超出范围，fill方法会静默忽略 copyWithin(insertIndex,beginIndex,endIndex) 作用：按照指定范围浅复制数组中的部分内容，插入到指定索引开始位置 index规则同上 2.7 转换方法 valueOf()：返回数组本身 toString()：调用每个数组元素的toString方法，将结果用逗号拼接并返回 toLocalString()：调用每个数组元素的toLocalString方法，将结果用逗号拼接并返回 join(seperate)：调用每个数组元素的toString方法，将结果用指定分隔符拼接并返回 如果数组中有元素是undefined，用上述方法转化会以空字符串表示（也就意味着分隔符是不会被忽略的） 2.8 栈与队列方法 push(item)：将item元素压入数组末尾，数组长度加1，返回数组长度 pop()：删除数组最后一个元素，数组长度减1，返回删除的元素 shift()：删除数组第一个元素，数组长度减1，返回删除的元素 unshift(item)：将item元素压入数组首部，数组长度加1，返回数组长度 方法组合 push(item) + pop() 使得数组可以当作栈来使用，满足先进后出 push(item) + shift() 使得数组可以当作队列使用，满足先进先出 unshift(item) + pop() ：反向队列 2.9 排序方法 reverse()：直接将数组反向排序 sort(compare)： 如果没有传入参数，则进行升序排列：现在每一项上调用String()函数进行转型，再进行比较，排列 可选参数：比较函数 比较函数接受两个参数 如果第一个参数应该在第二个参数前面，则返回负值 如果第一个参数应该在第二个参数后面，则返回正值 如果相等，则返回0 升序排列的比较函数示例 二者是对原数组进行修改，并返回原数组的引用 2.10 操作方法 concat(newEle1,newEle2,...)： 在现有数组的基础上创建一个新数组，即复制一份数组并且能够在这份数组后面加些东西 slice(beginIndex,endIndex) 创建一个包含原数组中一个或多个元素的新数组 splice() 对原数组进行删除元素，插入元素，替换元素等操作 删除：splice(deleteIndex,deleteNum) 插入&#x2F;替换：splice(InsertIndex,deleteNum,newEle1,newEle2,...) 2.11 搜索和位置方法 indexOf(item) 从头开始找，返回指定元素的在数组中的索引 lastIndexOf(item) 从末尾开始找，返回指定元素的在数组中的索引 include(item) 判断数组中是否包含指定元素，返回布尔值 注意判断相等的时候是严格相等，即 === find((element,index,array)=&gt;&#123;条件&#125;) 找到满足断言函数的第一个数组元素 findIndex((element,index,array)=&gt;&#123;条件&#125;) 找到满足断言函数的第一个数组元素的索引 2.12 迭代与递归 3. Map &amp; Set3.1 Map抽象数据类型，存储键值对，会记录顺序因此可迭代，键值可以是任意JavaScript类型 3.1.1 API 创建Map对象 可以传入可迭代对象作为参数 基本操作 新增键值对，set(&quot;key&quot;,&quot;value&quot;)，返回Map实例，可连续调用 查询是否有对应键：has(&quot;key&quot;)，存在则返回true 获取对应key下的value：get(&quot;key&quot;)，返回对应value 删除：delete(&quot;key&quot;) clear() 获取迭代对象 keys()、values()、entries() 与Object用法相同，返回可迭代对象 回调函数 forEach(()=&gt;&#123;&#125;) 3.1.2 Map VS Object实际上Map能做的Object基本都能实现，二者差异与选择如下 内存占用：Map优于Object（给定内存，Map 大约可以比 Object 多存储 50%的键&#x2F;值对） 插入性能：Map优于Object 查找速度：Object优于Map 删除性能：Map优于Object 3.2 Set抽象数据类型，存储不重复的值，会记录顺序因此可迭代，值可以是任意JavaScript类型 3.2.1 API与Map基本相同，可以认为是增强版的Map 创建Set 基本操作 新增值，add(&quot;value&quot;)，返回Set实例，可连续调用（添加重复的值无效） 查询是否有对应值：has(&quot;value&quot;)，存在则返回true 删除：delete(&quot;value&quot;) clear()，delete会返回布尔值表示删除是否成功 获取迭代对象 values()、entries() 与Object用法相同，返回可迭代对象 回调函数 forEach(()=&gt;&#123;&#125;) 八、 对象、类与面向对象编程1. 理解对象2. 创建对象2.1 工厂模式 可以快捷创建多个近似对象 但是没法解决对象标识问题，即创建的对象是什么类型 2.2 构造函数模式 相较于工厂模式，构造函数模式有以下几点不同 没有显示的创建对象 属性和方法直接赋值给了this（指向实例） 没有return 构造函数模式，构造函数可以写成函数声明的形式或者函数表达式的形式，如下面两种形式都是可以的 1. 构造函数也是函数构造函数和普通函数的唯一区别就是调用方式不同，任何函数只要使用new操作符调用就是构造函数，不使用就是普通函数 这里要记住，在调用一个函数而没有明确设置 this 值的情况下（即没有作为对象的方法调用，或者没有使用 call()&#x2F;apply()调用），this 始终指向 Global 对象（在浏览器中就是 window 对象）。 2. 构造函数的问题前提：JavaScript中定义函数就相当于是创建一个对象,比如下面定义函数的语句this.sayName = new Function(&quot;console.log(this.name)&quot;); //逻辑等价 那么外我们创建了多个person实例，每个实例都需要一个sayname对象，会导致空间资源的浪费，我们需要一个东西来共同使用吗，于是有了原型 2.3 原型模式1. 原型理解1.1 函数，函数原型，函数实例 每个函数都会创建一个prototype属性，这个属性指向一个一个对象，称为这个函数的原型； 函数原型 函数原型中存在一个constructor属性，这个属性指向原型的构造函数，会根据构造函数的内容来补充完善原型。 函数原型中也存在prototype属性，指向函数原型的原型，实际上就是父类原型 比如我们创建了一个person对象实例(默认继承object)，则person.__proto__.__proto__== Object.prototype 每个函数的所有实例都可以通过prototype属性来访问到函数原型，因此在函数原型上面定义的属性和方法可以被对象实例共享(类似于java中的静态变量和静态方法组成的一个静态对象) 1.2 相关API instanceof 检查实例的原型链中是否包含指定构造函数的原型 console.log(person1 instanceof Person); // true console.log(person1 instanceof Object); // true console.log(Person.prototype instanceof Object); // true isPrototypeOf 判断当前对象是否是参数对象的原型对象 console.log(Person.prototype.isPrototypeOf(person1)); &#x2F;&#x2F; true console.log(Person.prototype.isPrototypeOf(person2)); &#x2F;&#x2F; true Object.getPrototypeOf()，返回参数的内部特性[[Prototype]]的值。例如 console.log(Object.getPrototypeOf(person1) &#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true console.log(Object.getPrototypeOf(person1).name); &#x2F;&#x2F; “Nicholas” setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一 个新值。 但是随意使用这个方法，改变继承关系，会给代码性能带来巨大隐患，所以推荐使用下面的方法来创建一个对象并为其指定原型 **Object.create()**：创建一个新对象，并为其指定原型 2. 原型层级2.1 理解在搜索对象属性的时候，是逐级往上查找的：比如我们目前有一个person1实例对象，查找person1.name，先从这个实例对象查找，找不到再去这个实例对象的原型查找，找不到再去原型的原型查找，一层层往上直到null（object的原型的原型就是null） 因此如果原型中存在name属性，实例中我人工添加了name属性，实际上返回的是实例中的name，将原型中的name遮蔽了 如果要取消这个遮蔽效果的话，得使用delete，如 delete person1.name 2.2 相关api **hasOwnProperty()**：用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自 Object的，会在属性存在于调用它的对象实例上时返回 true 3. 原型和in操作符有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上。来看下面的例子 结合in操作符和hasOwnProperty方法，可以判断一个属性是否只存在于原型不存在于实例 在 for in循环中使用in 操作符时，其会返回所有 可以通过对象访问到 可以被枚举的属性遮蔽原型中不可枚举（[[Enumerable]]特性被设置为 false）属性的实例属性也会在 for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的 其他API Object.keys()：接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。 Object.getOwnPropertyNames()：列出所有实例属性，无论是否可以枚举 4. 属性枚举顺序for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnProperty\u0002Symbols()以及 Object.assign()在属性枚举顺序方面有很大区别 for-in 循环、Object.keys() 枚举顺序不确定，取决于js引擎 Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。 2.4 对象迭代需要迭代对象属性，就需要把对象内容转换为序列化的更重要的是可迭代的，这要求其具有一定的格式（比如说数组），下面两个静态方法接受一个对象，返回其内容的数组 Object.values(): 接受一个对象，返回对象值的数组 Object.entries(): 接受一个对象，返回键值对的数组 注意，如果进行对象复制，二者进行的是浅复制，即数组中的对象和对象中的对象是同一块内存空间， 1. 其他原型语法为了简化原型定义，减少代码冗余，可以通过对象字面量来重写原型 但是这样有个问题，就是对象字面量会完全重写，即将原型全部覆盖，导致其原来默认有的constructor属性被覆盖掉了，其默认指向object。这会导致我们不能再通过constructor来识别类型，但是instanceof还是可以使用 如果原型的constructor属性很重要，在定义原型的时候加入这个属性不失为一种可能的方法，如 但是对象字面量中的属性的特性[[Enumerable]]时默认为true，即可枚举；但是原生的constructor是不可枚举的，所以可以通过defineProperty来配置这个属性 2. 原型的动态性实例持有的是原型的指针，这个指针是构造函数传递给实例的，所以当创建实例后，原型发生重写之外的其他修改，实例可以调用修改后的原型，如 但是如果实例创建后，原型进行重写，则会导致实例访问不到重写后的原型，因为重写原型相当于抛弃了原来的原型，为重写的原型开辟一段新的空间，构造函数指向新原型，但是因为实例是在重写原型前创建，所以其指向旧原型 借图理解： 3. 原生对象的原型JavaScript的原生引用类型的构造函数如Array，String也是有原型的，其上会定义一些默认的实例方法，如 console.log(typeof Array.prototype.sort); &#x2F;&#x2F; “function” console.log(typeof String.prototype.substring); &#x2F;&#x2F; “function” 因此我们可以给原生对象的原型定义新的方法，这样会使得原生对象可以调用我们定义的方法，但是不推荐这么做，因为可能会导致误会和命名冲突，如果需要新增方法的话，建议创建一个自定义的类，继承特定的原生对象构造函数 4. 原型的问题原型成也共享，败也共享，其无法处理每个实例都需要自己的一份不共享的数据的情况。如果是简单的属性值，实例可以通过定义同名的属性进行遮蔽，从而创建自己的一份数据备份，而不会修改原型的数据值；关键在于引用类型的数据，如数组 如上：person1调用了friends数组的push方法， 修改了数组；理想的情况是person1有自己的friend数组并修改，但实际上这个修改的是原型的friend，无法创建自己的数据副本。所以实际开发中不会单独使用原型 3. 继承面向对象语言支持两种继承：接口继承、实现继承；因为ECMAScript中没有函数签名，所以接口继承不可能实现，只能是实现 实现继承，其实现方式就是原型链 函数签名：定义了一个函数的输入输出，如参数个数类型，返回值类型，抛出的异常等；js中显然没有这些东西 3.1 原型链重写子类的prototype为父类的实例，使得子类实例的原型的原型为父类的原型，构建一条原型链，实现继承。 修改之后： 原型链扩展了前面描述的原型搜索机制。我们知道，在读取实例上的属性时，首先会在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型。在通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型。对前面的例子而言，调用 instance.getSuperValue()经过了 3 步搜索：instance、SubType.prototype 和 SuperType.prototype，最后一步才找到这个方法。对属性和方法的搜索会一直持续到原型链的末端。 1. 默认原型 默认情况下，所有引用类型都继承自Object对象，即所有函数的原型的原型都是object 的原型 2. 判断原型和实例的关系原型和实例的关系可以通过两种方式来确认 instanceof() console.log(instance instanceof Object); &#x2F;&#x2F; true console.log(instance instanceof SuperType); &#x2F;&#x2F; true console.log(instance instanceof SubType); &#x2F;&#x2F; true 从技术上讲，instance 是 Object、SuperType 和 SubType 的实例，因为 instance 的原型链中包含这些构造函数的原型。结果就是 instanceof 对所有这些构造函数都返回 true。 isPrototypeOf(): console.log(Object.prototype.isPrototypeOf(instance)); &#x2F;&#x2F; true console.log(SuperType.prototype.isPrototypeOf(instance)); &#x2F;&#x2F; true console.log(SubType.prototype.isPrototypeOf(instance)); &#x2F;&#x2F; true 3. 关于方法子类实例中定义同名方法可以覆盖子类原型（父类实例）的方法，自然也可以覆盖子类原型的原型即父类实例的方法，实现重载 当子类继承父类后（将子类原型重写为父类实例），使用对象字面量重写子类原型，子类开始的原型链就断开了，因为对象字面量实际上是一个object对象，相当于使得子类继承自object 4. 原型链的问题 会将父类实例的属性变为子类原型的属性，使得数据只有一份，被所有子类所共享，与上面说的原型的问题相同 子类在实例化的时候无法给父类传参，需要给父类传参的话只能在重写子类原型的时候进行，而这会影响到所有子类 3.2 盗用构造函数由于原型链存在父类实例即子类原型的引用类型的数据会被所有子类实例共享问题，所以可以通过盗用构造函数使得子类实例有自己的一份引用类型数据，基本思路：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和 call()方法以新创建的对象为上下文执行构造函数。来看下面的例子： 通过SuperType.call(this)使得 SuperType构造函数在SubType的实例对象的上下文中执行了，这相当于在新的SubTyep对象上运行了SuperType()函数中所有初始化代码，结果就是每个实例对象都会有自己的一份colors属性 1. 传递参数相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。来看下面的例子： 2. 盗用构造函数的问题 必须在构造函数上定义方法和属性以实现对父类的继承，这导致函数不能重用 子类无法访问父类原型上的方法属性，这要求继承链中所有节点都是用盗用构造函数的方式进行 因此盗用构造函数也无法单独使用 3.3 组合继承基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。来看下面的例子： 通过盗用构造函数使得每个子类实例都有自己的一份引用类型的属性color，通过原型链继承使得sayname方法可以公用，好！ 3.4 原型式继承原型式继承： 目标：使不自定义类型也可以通过原型实现对象之间的信息共享 这个 object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制。来看下面的例子： 适用的情况：目前已有一个对象实例，想要在这个实例的基础上再创建一个对象 特点：引用类型变量会共享，相当于clone了两个person ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化，其接受两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选） 原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合 我们要使得对象实例间共享方法与数据，通常是需要顶一个一个构造函数以形成其原型使之共享于实例之间。而原型式继承则借助于已有对象的原型作为共享的媒介，因此不需要重新定义一个构造函数了 3.5 寄生式继承其基本思路是：以某种方式创建一个对象，再以某种方式增强该对象，最后返回 寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。object()函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。 3.6 寄生式组合继承1.组合式继承的问题组合式继承存在效率问题，即父类的构造函数会被调用两次：一次是在子类重写原型时候被调用；一次是在子类实例被创建时被调用 name 和 colors都是 SuperType 的实例属性，重写子类的原型后，其会现成为subType的原型属性。调用子类的构造函数时，其会先调用父类的构造函数，因此它们又成为SubType的实例的属性，遮蔽原型上的同名属性，这会导致实例和原型上都有name和color属性，造成浪费 2. 解决问题看不明白了，，， 通过寄生式组合继承解决。思路：使用寄生式继承来继承父类原型，然后将返回的新对象赋给子类原型，基本模式如下 这个 inheritPrototype()函数实现了寄生式组合继承的核心逻辑。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的prototype 对象设置 constructor 属性，解决由于重写原型导致默认 constructor 丢失的问题。最后将新创建的对象赋值给子类型的原型。如下例所示，调用 inheritPrototype()就可以实现前面例子中的子类型原型赋值： "},{"title":"React学习笔记","date":"2022-09-22T08:48:32.000Z","url":"/2022/09/22/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["React、前端","/tags/React%E3%80%81%E5%89%8D%E7%AB%AF/"]],"categories":[["undefined",""]],"content":"1. 教程井字棋1.1 基本概念react中是实现方式是通过js的继承，继承自React.conpoment，是React组件类,通过继承其能够实现以下几点 子组件存在render方法，其使用JSX语法，能够返回一个html结构，从而能够被其他组件当成标签来使用，实现组件化 其中如果要使用js语句的话，用&#123;&#125;括起来即可 子组件可以访问this.props对象来获取父组件传递给自己的属性or方法 子组件可以自定义状态属性：this.state，并且保存在state中的属性发生改变后，子组件及子组件的子组件的render函数中定义的部分界面会重新渲染 1.2 加深理解下面以井字棋程序作为例子，其中有三个类：Square、Boar、Game 个人对于prop和state的工作原理的粗浅理解 prop属性能够实现的原因 父组件在调用子组件，会定义其属性，调用的形式是以标签的方式进行的，这个实际上是在创建一个子组件的实例对象（因为子组件是类），然后将属性最为参数传递给子组件 子类的构造函数中会首先将参数给super()方法，通过盗用构造函数的方式使得父类（React.conponent）的构造函数在子类的构造函数的其他语句执行前先执行（即将父类定义的一些每个实例所独有的属性，在子类上重新定义一次） 而这些属性中应当包括props属性，并且将传入的参数赋给了这个属性，因此才能在子组件的实例中通过this.props来访问父组件传递给子组件的参数 而这个可以直接通过函数组件来实现，因此如果只需要props而不需要state的话，实际上是不需要通过继承来实现组件的创建，而可以直接通过函数来定义，如 state属性实现原因 首先父类（React.conpoment）中应当存在一个state属性，子类中继承了这个属性并且能够对其进行修改 其次父类中应该还安排了一些方法来实现对这个属性的监听，使之一旦发生改变，就使得当前组件和其子组件的所有页面内容都重新渲染，实现数据动态改变 render() 个人感觉类似于 Vue中的template？ 1.3 父子组件通信的实现方式在react中，父子组件通信主要是通过状态提升实现的 父组件和子组件区分，A组件调用B组件，A是父组件，B是子组件 状态提升具体指的是 本来是B需要管理自己的state和A传给B的prop对象 而如果想要实现二者的数据通信，以及父组件A对子组件B的定义数据的统一管理的话，可以进行状态提升 具体来说，就是将子组件B的state中需要统一管理的数据，以数组的形式保存在父组件A中，然后A再通过prop属性，将B需要的特定属性传递给B，当B需要修改数据值时，可以通过：A将自己的方法传递给B，B通过调用A的方法来修改其state，从而修改原本属于自己的值的方式进行。 这样就实现了父组件对子组件数据的统一管理，以及数据通信 1.4 列表中的key 列表中的key的作用 react为了效率，在更新列表的时候，是不会把原来的每一个列表项全都删除然后重新渲染的，而是会判断更新后的列表和之前的列表有无重合部分，然后只更新重合部分以外的其他部分 而key的作用就是判断哪些是重合部分，然后来决定是否需要销毁还是新建还是不变 key 是 React 中一个特殊的保留属性（还有一个是 ref，拥有更高级的特性）。当 React 元素被创建出来的时候，React 会提取出 key 属性，然后把 key 直接存储在返回的元素上。虽然 key 看起来好像是 props 中的一个，但是你不能通过 this.props.key 来获取 key。React 会通过 key 来自动判断哪些组件需要更新。组件是不能访问到它的 key 的。 2. React官方文档2.1 JSX 上述语句就是JSX，是JavaScript的一个语法扩展 其中我们可以嵌入JS代码，用&#123;&#125;引用；也可以讲JSX作为一个表达式，可以作为参数或者返回值；可以为JSX代码中的标签加上属性，或者指定子标签 JSX最后实际上会被Babel转译成一个名为React.createElement()的函数调用，以下了两种代码等价 这些对象成为react元素，描述了你希望在屏幕上能看到的内容，React通过读取这些对象来构建dom以及保持更新 2.2 元素渲染 将元素渲染为DOM 想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()： ReactDOM.render(element, document.getElementById(&#39;root&#39;)); 现在的渲染方式好像变了？ 得这样子才行？？ 更新已经渲染的dom元素 React元素是不可变对象，一旦创建就不能修i该其子元素或者属性，所以要更新DOM元素也就是UI的方式只能是覆盖，即创建一个全新的元素，将其传入ReactDOM.render()。 React 只更新它需要更新的部分 2.3 组件&amp;props 函数组件和class组件 函数组件 这个函数是一个有效的React组件，因为它接受唯一带有数据的props对象并返回一个react元素，本质上是js函数 class组件 上述两个组件时等效的 ‘注意组件名必须以大写字母开头，因为小写字母开头的组件会被React视为原生DOM标签’ 渲染组件 React元素不仅是DOM元素，也可以时自定义组件，如const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。 组合组件：组合起来的组件 提取组件，相当于使得组件抽象化，提取组件形成可复用的组件库 Props是只读的不可修改的 2.4 State &amp; 生命周期 state只有在class组件中才有，在函数组件中没有 state的赋值只能在constructor方法中进行，其他地方如果要进行修改的话得调用 this.setState()方法 state值更新的时候，其会动态渲染组件中用到state对应值的地方 state的数据是向下流动的，可以通过将state的数据作为props，传递给当前组件的子组件，实现数据交流 这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。 如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。 生命周期：每个class组件都有自己的生命周期函数 componentDidMount()：组件挂载 componentWillUnmount()：组件卸载 … … 2.5 事件处理 事件处理中不能通过return false来取消默认行为，而是得显示地写出e.preventDefault();，如： 前提：在 JavaScript 中，class 的方法默认不会绑定 this 所以如果我们要将class中的方法当作回调函数，传递给子组件的话，需要手动为其绑定this,一共有三种绑定方式 第一种，如上，直接在构造函数通过bind函数将handClick方法的this属性绑定为当前类实例的this（这样才能在之后调用实例的setState） 第二种，在需要调用函数的地方采取箭头函数的形式，如 这会自动为这个方法绑定当前实例的this 但是这会导致回调函数传入子组件，会导致这些子组件每次都重新渲染，新增不必要的开销 第三种，函数通过函数表达式的方式进行定义 建议采用第一种 2.6 条件渲染 额 可以通过 if else、&amp;&amp;、三目，来决定渲染的或者返回的元素 可以返回null，但是组件的生命周期仍然生效 2.7 列表 &amp; key 在React中，将列表转化为元素，可以通过map()方法实现，如 列表项应当设置一个key属性，用于React高效渲染 key属性不要求全局唯一，只要在兄弟节点处唯一即可 key属性应当在数组的上下文中，记住map映射的元素列表要设置一个key即可 key属性是无法被访问到的，如果要使用key属性保存的变量，请使用其他属性再保存一次、 key属性在未配置时，会使用每一个元素的索引当作key值，这样当数组元素顺序改变时，会导致key值混乱，从而使得性能down，所以不建议用索引当key值，最好用一组数据中各不相同的值来作为key值 2.8 表单受控组件：在React中，表单元素维护自己的状态并且保存在组件的state属性中，并且只能通过setstate方法来更新，React的state属性时表单元素的唯一数据源。渲染表单的React组件控制着用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素就叫做“受控组件” React中不存在v-model之类的绑定语句，需要动态绑定数据的话得自己实现，如： input：用value表示输入框的内容，输入框的内容与value属性值同步 无论什么情况，如果value的值如果直接被指定，则输入框的内容不可更改，如 当未设置onChange函数时，只有当设置为null或者undefined或者是变量的话才可更改；当设置onChange函数时，value设置为变量也可更改 texarea： 不再使用文本元素作为子元素，而是和input一样使用value属性 &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; select：创建下拉列表标签 一般html写法 用selected表示选中 React写法 在根标签select中设置value，来体现选中的是哪个标签 可以通过multiple属性+value数组来实现多选 2.9 状态提升在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步 state。 优点：易于排查bug：当有问题组件出现时，可以检查其Props属性，并向上追溯到更新这个props的组件的方法，从而定位bug 2.10 组合与继承 包含关系 需求是当设计FancyBorder，其具体内部内容是动态的不确定的，需要留一个“洞”给他。而props中有一个特殊的属性children，可以自定义组件的子元素获取到，并进行对应操作渲染，如 本来如果要访问props.children的话，是得要在组件的属性中定义“children&#x3D;{… …}”，但是React将children独有了，将其值定义为组件间包裹的子组件，所以可以填充这个洞 而如果想要留多个洞的话，就直接在属性里面设置即可；即配置props，如何组件内部再获取props中对应的元素进行调用渲染，而不用像vue那样设置插槽啥的，如 2.extra React哲学创建react的小项目 将设计好的UI划分为组件层级 更具单一功能原则进行划分 设计静态代码 编写静态代码和添加交互功能应当分开，因为编写静态代码要写大量代码但是不用考虑过多细节；编写交互功能要考虑大量细节而不用写太多代码 编写静态代码不应当使用state，因为state是可更改的属性，且更改会重新触发页面渲染，所以仅应当在交互的时候使用 简单项目可以选择自上而下构建组件，复杂项目建议自下而上构建组件并带上测试 确定UI state的最小完整表示 首先确认当前程序需要哪些数据： 包含所有产品的原始列表 用户输入的搜索词 复选框是否选中的值 经过搜索筛选的产品列表 判断这些数据是否是state，判断标准如下 该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。 该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。 你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。 包含所有产品的原始列表是经由 props 传入的，所以它不是 state；搜索词和复选框的值应该是 state，因为它们随时间会发生改变且无法由其他数据计算而来；经过搜索筛选的产品列表不是 state，因为它的结果可以由产品的原始列表根据搜索词和复选框的选择计算出来。 判断得到的state有 用户输入的搜索词 复选框是否选中的值 确定state放置的位置 找到根据这个state渲染的所有组件 找到这些组件的共同所有者组件（在组件层级上高于所有需要这个state的组件） 该共同所有者组件或者比它层级高的组件拥有该state 如果没有合适的位置，那就新创一个组件来存放该state，并将其置于高于共同所有者组件的位置 实现数据回流 父组件设置处理方法， 子组件设置监听方法，当子组件的监听方法监听到事件发生后，通知父组件的处理方法进行执行，修改相应state，同时重新渲染父组件和其下的所有子组件 3. Hook3.1 Hook简介Hook是什么，Hook就是让我们在函数组件中也能够调用class中才有的React特性的方法，称作钩子 Hook需要引入： Hook 是什么？ Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。稍后我们将学习其他 Hook。 什么时候我会用 Hook？ 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。 3.2 使用 State HookState Hook相当于在函数组件中实现了class组件中能够定义状态的React特性 定义state 在class中，我们在constructor中通过this.state来配置初始的state；通过this.setState方法来修改state 在使用Hook的函数组件中，我们通过useState() 方法来定义一个state和修改state的方法 useState 需要哪些参数？ 唯一的参数就是初始 state。 useState 方法的返回值是什么？返回值为：当前 state 以及更新 state 的函数 示例写法：const [count, setCount] = useState(0); 通过数组解构函数获取变量初始值和修改数组值的方法 读取state 在class中，需要读取state，使用this.state.count 在函数中，需要读取state，直接用count 更新state 在class中 在函数中 3.3 使用Effect HookEffect Hook的作用实际上是在函数组件中实现class组件中的生命周期函数（componentDidMount、componentDidUpdate、componentWillUnmount） Effect Hook 使用示例 我们将函数传入useEffect()函数，其将再浏览器每一次渲染前重新执行（这意味着除了最开始的渲染，每次改变导致的更新，浏览器都会先清除上一次的副作用再重新调用effect函数），在页面挂载后执行副作用的函数； 我们可以在函数中设置返回值，这代表当前副作用的清除操作，其会在组件卸载的时候执行,因为浏览器每一次渲染都会执行清除操作，所以清除函数在每一次渲染时都会被调用 每一次重新渲染都要重新执行effect的原因在于：实现componentDidUpdate，因为重新渲染会导致一些组件内部属性发生改变，而effect中可能会定义有组件内容或者获取组件属性的方法，如果没有重新执行的话， Effect Hook的作用 可以使用多个Effect实现关注点分离：在class中，由于生命周期的不同，我们往往需要把相同逻辑的代码拆分到不同的生命周秋中，而不同逻辑的代码聚合到单一生命周期中，这使得代码可读性差以及违反了单一职责原则；而使用Effect Hook后，我们可以将相同逻辑的代码聚合到单一的Effect中，实现关注点分离 为什么每次更新都需要运行Effect 总结：实现生命周期中的componentDidUpdate()部分 解释：如果不是在每次更新时都运行Effect的话，若Effect中的函数在页面状态更新时也应该触发，则会出现bug： 比如显示好友在线的功能，除了我们上线时候的一次性获取好友在线的状态，当我们在线时，每当好友上线触发状态变化，我们都应当能够得知（这也就要求Effect需要在每一次页面状态改变时重新运行），而不是得重新登录一次才能够获得好友状态变化 通过跳过Effect进行性能优化 Effect函数在页面每次渲染的时候都需要运行可能会导致性能降低，可以设置第二个参数：数组类型，使得仅当数组中的变量的变化触发的页面渲染才触发当前Effect 例如： 特殊用法： 如果想要一个只运行一次的effect，只需要将第二个参数设置为空数组[]，这意味着不会有其他变量改变触发的页面渲染会调用当前的effect函数，同时，effect的清除函数也不会被调用 3.4 Hook规则 rule1： 只在最顶层使用Hook，不要再循环、条件、嵌套语句中调用Hook。 目的：保证Hook在每次渲染中都按照相同的顺序执行 解决的问题：避免因为Hook顺序错误导致bug。如 rule2： 只在React函数中调用Hook，不要在普通的JavaScript函数中调用Hook 可以在React的函数组件中调用Hook 可以在自定义的Hook中调用其他Hook 3.5 自定义Hook自定义Hook实际上就是将可复用的包括hook函数的组件逻辑，提取到可重用的函数中 遇到的问题：组件逻辑重复 比如我有两个函数都需要重用上图框起来的组件逻辑，直接复制粘贴显然是不合理的，合理的做法是将组件逻辑抽象出一个自定义Hook函数，然后在两个函数中调用 question1：为什么需要是自定义Hook函数，一般的函数不行吗？ 解答：因为抽象出来的函数的逻辑中包含了Hook函数的调用，如果只是一般函数的话，React无法自动检查函数代码中是否违反了Hook规则 question2：自定义Hook函数如何定义？ 解答：以use开头的函数就是自定义Hook函数，如 其对于参数以及返回值没有其他要求 解决方法：自定义Hook函数，重复部分调用 question1：在两个组件中使用相同的 Hook 会共享 state 吗？ 解答：不会。自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。 question2：自定义 Hook 如何获取独立的 state？ 每次调用 Hook，它都会获取独立的 state。由于我们直接调用了 useFriendStatus，从 React 的角度来看，我们的组件只是调用了 useState 和 useEffect。 我们可以在一个组件中多次调用 useState 和 useEffect，它们是完全独立的。 extra：问题记录1. forEach映射问题 问题描述 products是一个数组，其中前三项有值，后三项为undefined 调用数组的forEach方法后，取到的product理应是数组中一项即但是返回的是整个数组 解决： 因为一个数组是双层的，里面还嵌套这一个数组 forEach只展开一次，所以下面的数组是它的第一项，还是一个数组 为什么呢？因为你不清楚map和forEach的用法就瞎用啊！！ 1.1 map array.map((item,index,arr)=&gt;callback,this) 参数： 回调函数的参数 必须 item：数组中的单个元素 必须 index：当前元素的序号 arr：当前元素属于的数组对象 this： 返回值：其会返回一个由回调函数的返回值所组成的数组，而之前的代码是这么写的： 用了push方法相当于把这新的数组给压入newProducts，就形成了双重数组。。。。。简单的错debug两小时，服了 1.2 forEach用户与map基本相同 1、map速度比forEach快 2、map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组，只会对原数组直接进行修改，返回undefined 3、map因为返回数组所以可以链式操作，forEach不能 4, map里可以用return（return的是什么，相当于把数组中的这一项变为什么（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了） ,而forEach里用return不起作用，forEach不能用break，会直接报错 1.3 debug小结 在理清程序的运行顺序后，可以在开发者工具上设置断点并执行： 如图将从235行开始按序执行 可以在右侧监听数据变化： "},{"title":"第一篇文章","date":"2022-09-22T07:12:24.000Z","url":"/2022/09/22/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","categories":[["undefined",""]],"content":"这是标题"},{"title":"Hello World","date":"2022-09-22T04:50:50.206Z","url":"/2022/09/22/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]