[{"title":"JavaScript学习","date":"2022-09-23T10:27:04.000Z","url":"/2022/09/23/JavaScript%E5%AD%A6%E4%B9%A0/","categories":[["undefined",""]],"content":"一. 语言基础1. 变量 var 作用域：函数级 可进行变量提升 允许冗余声明 在全局中声明会作为 window 对象的属性 let 作用域：块作用域 不可变量提升 不允许冗余声明 全局声明不会作为window的属性 const 声明的变量必须同时初始化，其他与let的用法相同 如果const声明的变量时引用类型，只需要保证引用类型的值不变，引用类型指向的对象可以改变 变量使用规范 const &gt; let 不适用var 2. 数据类型基础数据类型：Undefined、Null、Boolen、Number、String、Symbol，Object 2.1 typeof操作符 typeof typeof是一个操作符，不是函数，但是可以传递参数 用法：typeof null // object typeof null 返回的是object对象而不是null。因为null 被认为是一个对空对象的引用 2.2 Undefined、Null、Boolean Undefined Undefined类型只有一个值，undefined 当var，let声明变量但是未指定初始值时，其值就是undefined 变量未声明，直接typeof该变量时，返回的也是undefined 因此建议变量声明时就初始化，这样当控制台输出undefined时，就可以确认这个变量是未声明的 Null Null类型只有一个值，null，表示一个空对象和的指针 如果声明的变量将来要保存对象的值，建议初始化为null（不然不初始化的话就是undefined，和对象以外的数据类型混淆） undefined是由null衍生而来，因此这段代码返回 true undefined == null Boolean 两个值 在控制流语句的时候，会自动执行其他类型值到boolen值的转化 2.3 NumberNumber类型包括整数和浮点数类型 0开头表示八进制，0x开头表示16进制 浮点数的存储压力大，能转化为整数的都会转化 不要测定某个浮点数的值！如 0.1 + 0.2 == 0.3 // false NaN：返回数值的操作失败了，不会抛出错误，会返回NaN，一个特殊的Number值 任何数除于0，NaN参与的运算，都会返回NaN 可以通过isNaN方法判断当前数据是否为NaN 正常数据，可转化为数据的字符串，布尔值等都不是NaN 数值转化方法：Number() parseInt() parseFloat Number()：将其他类型数据转化为数值 parseInt()：转化为整数 第一个参数是带转化参数 转化规则需要则查阅 第二个参数可选，表示转化进制 2.4 String2.4.1 字符串基本 带斜杠的表示转义字符，可以表示一些字符字面量，转义字符在计算长度时一般计算为1 字符串不可变。要修改只能删了再建 字符串转化方法：toString() String() null，undefined没有toString方法，要转化只能通过String(null)之类 数字使用toString方法时，参数为转化进制，如 let a=16; a.tostring(16); // &#39;a&#39; 2.4.2 模板字面量 语法：`…（内容）&#96; 作用 可以直接在字符串内部换行，效果和 \\n 一样 可以使用字符串插值：$&#123;变量名&#125;，在字符串内调用外面变量，如 从而避免一步步拼接字符串 可以使用标签函数 2.5 SymbolES6新增类型，用于创建唯一记号，进而用作非字符串形式的对象属性 2.6 Objectlet o = new Object(); 3. 操作符 位操作符 与，或，非，异或 关系操作符 &lt; , &gt; , &lt;= , &gt;= , 比较字符串与字符串时，会比较字符串的ASCII编码，可以进行排序 在比较数字与字符串时，会先将字符串转化为数字再进行比较，如果字符串转化后为NaN则返回false（NaN和任何数字比较都返回false） 逗号操作符： let num1 = 1, num2 = 2, num3 = 3; let num = (5, 1, 4, 8, 0); // num 的值为 0 3.1 等于操作符 等于操作符分为 等于 不等于，全等 不全等 两类四种 等于和不等于== ！= 在比较前会做强制类型转化 布尔值，字符串会转化成数字再和数值比较 对象和不是对象的操作数比较，会先调用对象的valueof方法取得原始值；如果两个都是对象操作数，则比较二者是否指向同一个对象 null &#x3D;&#x3D; undefined ，且二者不能转化为其他类型的值再进行比较，即其他值都不等于 null 或 undefined NaN 不等于 任何操作数，包括NaN 全等和不全等=== ！== 不做强制类型转化 null !&#x3D;&#x3D; undefined 4. 语句 标签语句，给语句加标签。语法： label: statement ，例子 start是一个标签，可以再后面通过break和continue语句引用，如 其会直接中断外层循环并跳出，不用自己再设置boolen值进行判断 with语句：将代码作用域设置为特定的对象。 语法with (expression) statement;，例子 with语句会影响和性能，不推荐使用 二. 变量、作用域、内存1. 原始值与引用值原始值指的就是Undefined、Null、Boolen、Number、String、Symbol这六个类型的值，保存原始值的变量存的就是这些值本身，是按值访问的，我们操作变量实际上就是操作这些值。引用值就是保存在内存中的对象，JavaScript中不能直接操作内存空间，保存引用值的变量存的是对象的地址，是按引用访问的。 不同点 引用值可以设置对象属性，原始值不行 二者复制方式不同 原始值是直接将值复制到新变量上（栈上），二者独立使用不干扰 引用值则复制的是引用，二者指向同一个堆上对象 传递参数 JavaScript函数传参是按值传递 如果是按引用传递的话，输出的应该是Greg；安置传递导致obj再函数内新建的对象，在执行完函数后自动销毁 原始值直接复制一份进去，不会对外面产生影响 引用值同样也是复制一份进去，但是由于指向的是同一个对象，所以可能会对外面产生影响 2. 上下文与作用域 每个上下文都有一个关联的变量对象（variable object）， 而这个上下文中定义的所有变量和函数都存在于这个对象上 简单来说，就是当前函数只能访问得到自己定义的变量以及他的父级函数以及父级的父级… 的变量，这些作用域形成一条作用域链，离当前函数越近排得越靠前。每当有需要查找的标识符时，就按照作用域链依次查找 作用域链增强：将某个作用域提升到作用域链的最前端 with语句 try&#x2F;catch中的catch语句 3. 垃圾回收 ⭐ 目的：管理内存，释放不必要的内存占用，提高利用率 基本思路：确定哪个变量不会再用，释放它的内存；周期性进行 实现方法：垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存 标记未使用的变量的两种策略：标记清理、引用计数 3.1 清理策略3.1.1 标记清理 步骤 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种） 然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉（因为这些变量都可能被调用） 在这之后标记还存在的变量就是待删除的，垃圾回收程序会做一次内存清理，销毁带标记的值并收回内存 效果 最常用的垃圾回收策略，周期性进行 脱离作用域的变量会被回收 3.1.2 引用计数 方法： 当一个值（内存空间）的引用数为0时，下次进行垃圾回收的时候会将其回收。 引用数计算方式：声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。 问题 循环引用 在这个例子中，objectA 和 objectB 通过各自的属性相互引用，意味着它们的引用数都是 2。在标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，objectA 和 objectB 在函数结束后还会存在，因为它们的引用数永远不会变成 0。如果函数被多次调用，则会导致大量内存永远不会被释放。 循环引用解决方式：在确定不使用的情况下，将引用变量设置为null 3.2 内存管理将内存占用量保持在一个较低的值可以让页面的性能更好，而优化内存占用的最佳手段就是只保存执行过程中的必要数据；如果不再必要，则设置为null （使得原先的值不再存在于上下文或者上下文变量的引用中），在下次垃圾回收时候被回收 如果时函数级变量，在函数执行完成后，变量值会自动脱离上下文，不用专门设置变量为null 设置为null的场景更多在于全局变量，因为其脱离上下文得等到整个程序结束 3.2.1 const 与 let 改善性能因为 const和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生。 3.2.2 隐藏类与删除操作V8 Javascript引擎在将代码编译为机器码时，会使用“隐藏类”，共用隐藏类有助于性能提升 创建对象 在创建实例对象时，实例对象会共用隐藏类，如 但是如果之后再实例的基础上进行动态属性复制，二者隐藏类将无法共享而是各自独有，而依据操作的频率以及隐藏类的大小会对性能造成不同程度的影响，如 解决方法：避免先创建再补充的动态属性复制，在构造函数中一次性声明所有属性 删除属性 删除(delete)属性会影响隐藏类共享 上述代码两个实例不再共享隐藏类，而解决方法是不要使用delete，而是直接将不需要的属性设置为null，这样不影响隐藏类共享，而且可以协助垃圾回收的进行 3.2.3 内存泄漏内存泄漏：内存空间持续暴露，无法回收 意外声明全局变量 此时，解释器会把变量 name 当作 window 的属性来创建（相当于 window.name &#x3D; ‘Jake’）。可想而知，在 window 对象上创建的属性，只要 window 本身不被清理就不会消失。解决方法，只要在变量声明前头加上 var、let 或 const 关键字即可，这样变量就会在函数执行完毕后离开作用域。 定时器导致内存泄漏 定时器一直允许，name就无法回收 闭包导致内存泄漏 上述函数中返回的函数引用到了原来函数内部的name变量，只要返回的函数还存在着，原来的函数中的name变量就始终无法回收 3.2.4 静态分配与对象池由于垃圾回收会降低浏览器性能，我们在想办法让垃圾回收的效率提高的同时，也需要想办法尽可能地减少垃圾回收的发生；理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。 浏览器决定何时运行垃圾回收运行的一个标准是对象的更替速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行。例如 如果频繁调用这个方法的话，就会不断由Vector对象的创建和脱离作用域，导致垃圾回收更快发生，解决办法就是不要在内部创建对象而是使用外面已经存在的对象 外面的对象在哪里创建呢？一个策略是使用对象池，即其本身持有一定数量的对象实例，需要使用则从中取出一个实例，不需要则归还，因为对象池中的对象始终存在，所以垃圾回收探测不会发现有对象频繁更替，减少运行频率 三、基本引用类型引用值（或者对象）是某个特定引用类型的实例，引用类型是将数据和功能组织到一起的结构，也被称为对象定义，但是它不等同于类。ECMAScript中也缺少面向对象编程语言的基本结构，包括类和接口。 注意：函数也是一种引用类型，也可以创建对应对象 1. Data1.1 创建Data对象Data是一种引用类型，可以创建Data的实例对象，创建方法如下 Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。支持的日期格式如下 Date.UTC()方法也返回日期的毫秒表示的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。例子如下 1.2 继承的方法toLocaleString()、toString()和 valueOf() toLocaleString()：返回与浏览器运行的本地环境一致的日期 toString()：：通常返回带时区信息的日期和时间 valueOf()：根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示 1.3 日期格式化方法 一些其他的接口需要则自行查阅 2. RegExp 具体语法需要用时再查 3. 原始值的包装类由于原始值包装类型的存在，JavaScript 中的原始值可以被当成对象来使用。有 3 种原始值包装类型：Boolean、Number 和 String。它们都具备如下特点。 每种包装类型都映射到同名的原始类型。 以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。（比如可以调用对应方法） 涉及原始值的语句执行完毕后，包装对象就会被销毁。 4. 内置单例当代码开始执行时，全局上下文中会存在两个内置对象：Global 和 Math。其中，Global 对象在大多数 ECMAScript 实现中无法直接访问。不过，浏览器将其实现为 window 对象。所有全局变量和函数都是 Global 对象的属性。Math 对象包含辅助完成复杂计算的属性和方法。 四、集合引用类型1. Object 创建方式 new Object()，之后动态赋值属性 以对象字面量的形式创建（不会调用Object的构造函数） 属性存取方式 点语法，即 Person.name之类（首选） 中括号，如Preson[“name”]，如果是字符串要加引号 其用处主要在于中括号内部可以使用变量，以及在点语法不合法的情况下 2. Array2.1 创建数组 new Array() 可以不传参，可以传长度，可以传数组元素 new可以省略 数组字面量，如 let arr1 = [1,2,3,4] 同Object，不会调用构造函数 Array.form(param1) 用于将类数组结构转化为数组实例 第一个参数是一个可迭代对象，或者是有一个length属性和可索引元素的结构 第二个可选参数：一个映射函数 第三个可选参数：指定映射函数中this的值 Array.of(param) 将一组参数转化为数组 如：Array.of(…[1,2,3,4]) // [1,2,3,4] 2.2 数组空位 创建数组的时候可以只输入逗号不输入具体值，其会创建对应长度，并且每个元素的值都是undefined的数组 ES6后，空位的值是undefined；ES6之前则不一定 所以建议如果要创建有空位的数组的话，将空位设置为undefined 2.3 数组索引 可以通过索引来访问数组元素 可以通过索引来新增数组元素 如果索引超出长度，则中间未定义的元素值为undefined 可以直接设置数组的length属性，来新增数组元素（值都为undefined） 可以通过length属性，方便地向数组末尾添加元素 2.4 检测数组 instanceof Array.isArray 2.5 迭代器方法 keys() values() entries()是数组上的三个检索数组内容的方法， 第一个返回数组索引的迭代器 第二个返回数组值的迭代器 第三个返回数组 索引&#x2F;值对 的迭代器 可以通过form方法，把迭代器转化为数组 可以通过 for-of 循环，遍历迭代器 for-of循环是只能遍历迭代器，其寻找下一个的方式是通过迭代器的next()方法 2.6 复制和填充 批量复制方法fill()和填充数组方法copyWithin() fill(value,beginIndex,endIndex) 作用：向一个数组中插入全部或部分相同的值 第一个参数；是填充的数值 beginIndex：开始填充的位置，可选，默认从头 endIndex：填充到哪里，可选，默认到末尾 其中index如果是负数，则表示从末尾开始，可通过加上数组长度来计算实际位置 如果index超出范围，fill方法会静默忽略 copyWithin(insertIndex,beginIndex,endIndex) 作用：按照指定范围浅复制数组中的部分内容，插入到指定索引开始位置 index规则同上 2.7 转换方法 valueOf()：返回数组本身 toString()：调用每个数组元素的toString方法，将结果用逗号拼接并返回 toLocalString()：调用每个数组元素的toLocalString方法，将结果用逗号拼接并返回 join(seperate)：调用每个数组元素的toString方法，将结果用指定分隔符拼接并返回 如果数组中有元素是undefined，用上述方法转化会以空字符串表示（也就意味着分隔符是不会被忽略的） 2.8 栈与队列方法 push(item)：将item元素压入数组末尾，数组长度加1，返回数组长度 pop()：删除数组最后一个元素，数组长度减1，返回删除的元素 shift()：删除数组第一个元素，数组长度减1，返回删除的元素 unshift(item)：将item元素压入数组首部，数组长度加1，返回数组长度 方法组合 push(item) + pop() 使得数组可以当作栈来使用，满足先进后出 push(item) + shift() 使得数组可以当作队列使用，满足先进先出 unshift(item) + pop() ：反向队列 2.9 排序方法 reverse()：直接将数组反向排序 sort(compare)： 如果没有传入参数，则进行升序排列：现在每一项上调用String()函数进行转型，再进行比较，排列 可选参数：比较函数 比较函数接受两个参数 如果第一个参数应该在第二个参数前面，则返回负值 如果第一个参数应该在第二个参数后面，则返回正值 如果相等，则返回0 升序排列的比较函数示例 二者是对原数组进行修改，并返回原数组的引用 2.10 操作方法 concat(newEle1,newEle2,...)： 在现有数组的基础上创建一个新数组，即复制一份数组并且能够在这份数组后面加些东西 slice(beginIndex,endIndex) 创建一个包含原数组中一个或多个元素的新数组 splice() 对原数组进行删除元素，插入元素，替换元素等操作 删除：splice(deleteIndex,deleteNum) 插入&#x2F;替换：splice(InsertIndex,deleteNum,newEle1,newEle2,...) 2.11 搜索和位置方法 indexOf(item) 从头开始找，返回指定元素的在数组中的索引 lastIndexOf(item) 从末尾开始找，返回指定元素的在数组中的索引 include(item) 判断数组中是否包含指定元素，返回布尔值 注意判断相等的时候是严格相等，即 === find((element,index,array)=&gt;&#123;条件&#125;) 找到满足断言函数的第一个数组元素 findIndex((element,index,array)=&gt;&#123;条件&#125;) 找到满足断言函数的第一个数组元素的索引 2.12 迭代与递归"},{"title":"React学习笔记","date":"2022-09-22T08:48:32.000Z","url":"/2022/09/22/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["React","/tags/React/"]],"categories":[["undefined",""]],"content":"1. 教程井字棋1.1 基本概念react中是实现方式是通过js的继承，继承自React.conpoment，是React组件类,通过继承其能够实现以下几点 子组件存在render方法，其使用JSX语法，能够返回一个html结构，从而能够被其他组件当成标签来使用，实现组件化 其中如果要使用js语句的话，用&#123;&#125;括起来即可 子组件可以访问this.props对象来获取父组件传递给自己的属性or方法 子组件可以自定义状态属性：this.state，并且保存在state中的属性发生改变后，子组件及子组件的子组件的render函数中定义的部分界面会重新渲染 1.2 加深理解下面以井字棋程序作为例子，其中有三个类：Square、Boar、Game 个人对于prop和state的工作原理的粗浅理解 prop属性能够实现的原因 父组件在调用子组件，会定义其属性，调用的形式是以标签的方式进行的，这个实际上是在创建一个子组件的实例对象（因为子组件是类），然后将属性最为参数传递给子组件 子类的构造函数中会首先将参数给super()方法，通过盗用构造函数的方式使得父类（React.conponent）的构造函数在子类的构造函数的其他语句执行前先执行（即将父类定义的一些每个实例所独有的属性，在子类上重新定义一次） 而这些属性中应当包括props属性，并且将传入的参数赋给了这个属性，因此才能在子组件的实例中通过this.props来访问父组件传递给子组件的参数 而这个可以直接通过函数组件来实现，因此如果只需要props而不需要state的话，实际上是不需要通过继承来实现组件的创建，而可以直接通过函数来定义，如 state属性实现原因 首先父类（React.conpoment）中应当存在一个state属性，子类中继承了这个属性并且能够对其进行修改 其次父类中应该还安排了一些方法来实现对这个属性的监听，使之一旦发生改变，就使得当前组件和其子组件的所有页面内容都重新渲染，实现数据动态改变 render() 个人感觉类似于 Vue中的template？ 1.3 父子组件通信的实现方式在react中，父子组件通信主要是通过状态提升实现的 父组件和子组件区分，A组件调用B组件，A是父组件，B是子组件 状态提升具体指的是 本来是B需要管理自己的state和A传给B的prop对象 而如果想要实现二者的数据通信，以及父组件A对子组件B的定义数据的统一管理的话，可以进行状态提升 具体来说，就是将子组件B的state中需要统一管理的数据，以数组的形式保存在父组件A中，然后A再通过prop属性，将B需要的特定属性传递给B，当B需要修改数据值时，可以通过：A将自己的方法传递给B，B通过调用A的方法来修改其state，从而修改原本属于自己的值的方式进行。 这样就实现了父组件对子组件数据的统一管理，以及数据通信 1.4 列表中的key 列表中的key的作用 react为了效率，在更新列表的时候，是不会把原来的每一个列表项全都删除然后重新渲染的，而是会判断更新后的列表和之前的列表有无重合部分，然后只更新重合部分以外的其他部分 而key的作用就是判断哪些是重合部分，然后来决定是否需要销毁还是新建还是不变 key 是 React 中一个特殊的保留属性（还有一个是 ref，拥有更高级的特性）。当 React 元素被创建出来的时候，React 会提取出 key 属性，然后把 key 直接存储在返回的元素上。虽然 key 看起来好像是 props 中的一个，但是你不能通过 this.props.key 来获取 key。React 会通过 key 来自动判断哪些组件需要更新。组件是不能访问到它的 key 的。 2. React官方文档2.1 JSX 上述语句就是JSX，是JavaScript的一个语法扩展 其中我们可以嵌入JS代码，用&#123;&#125;引用；也可以讲JSX作为一个表达式，可以作为参数或者返回值；可以为JSX代码中的标签加上属性，或者指定子标签 JSX最后实际上会被Babel转译成一个名为React.createElement()的函数调用，以下了两种代码等价 这些对象成为react元素，描述了你希望在屏幕上能看到的内容，React通过读取这些对象来构建dom以及保持更新 2.2 元素渲染 将元素渲染为DOM 想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()： ReactDOM.render(element, document.getElementById(&#39;root&#39;)); 现在的渲染方式好像变了？ 得这样子才行？？ 更新已经渲染的dom元素 React元素是不可变对象，一旦创建就不能修i该其子元素或者属性，所以要更新DOM元素也就是UI的方式只能是覆盖，即创建一个全新的元素，将其传入ReactDOM.render()。 React 只更新它需要更新的部分 2.3 组件&amp;props 函数组件和class组件 函数组件 这个函数是一个有效的React组件，因为它接受唯一带有数据的props对象并返回一个react元素，本质上是js函数 class组件 上述两个组件时等效的 ‘注意组件名必须以大写字母开头，因为小写字母开头的组件会被React视为原生DOM标签’ 渲染组件 React元素不仅是DOM元素，也可以时自定义组件，如const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。 组合组件：组合起来的组件 提取组件，相当于使得组件抽象化，提取组件形成可复用的组件库 Props是只读的不可修改的 2.4 State &amp; 生命周期 state只有在class组件中才有，在函数组件中没有 state的赋值只能在constructor方法中进行，其他地方如果要进行修改的话得调用 this.setState()方法 state值更新的时候，其会动态渲染组件中用到state对应值的地方 state的数据是向下流动的，可以通过将state的数据作为props，传递给当前组件的子组件，实现数据交流 这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。 如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。 生命周期：每个class组件都有自己的生命周期函数 componentDidMount()：组件挂载 componentWillUnmount()：组件卸载 … … 2.5 事件处理 事件处理中不能通过return false来取消默认行为，而是得显示地写出e.preventDefault();，如： 前提：在 JavaScript 中，class 的方法默认不会绑定 this 所以如果我们要将class中的方法当作回调函数，传递给子组件的话，需要手动为其绑定this,一共有三种绑定方式 第一种，如上，直接在构造函数通过bind函数将handClick方法的this属性绑定为当前类实例的this（这样才能在之后调用实例的setState） 第二种，在需要调用函数的地方采取箭头函数的形式，如 这会自动为这个方法绑定当前实例的this 但是这会导致回调函数传入子组件，会导致这些子组件每次都重新渲染，新增不必要的开销 第三种，函数通过函数表达式的方式进行定义 建议采用第一种 2.6 条件渲染 额 可以通过 if else、&amp;&amp;、三目，来决定渲染的或者返回的元素 可以返回null，但是组件的生命周期仍然生效 2.7 列表 &amp; key 在React中，将列表转化为元素，可以通过map()方法实现，如 列表项应当设置一个key属性，用于React高效渲染 key属性不要求全局唯一，只要在兄弟节点处唯一即可 key属性应当在数组的上下文中，记住map映射的元素列表要设置一个key即可 key属性是无法被访问到的，如果要使用key属性保存的变量，请使用其他属性再保存一次、 key属性在未配置时，会使用每一个元素的索引当作key值，这样当数组元素顺序改变时，会导致key值混乱，从而使得性能down，所以不建议用索引当key值，最好用一组数据中各不相同的值来作为key值 2.8 表单受控组件：在React中，表单元素维护自己的状态并且保存在组件的state属性中，并且只能通过setstate方法来更新，React的state属性时表单元素的唯一数据源。渲染表单的React组件控制着用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素就叫做“受控组件” React中不存在v-model之类的绑定语句，需要动态绑定数据的话得自己实现，如： input：用value表示输入框的内容，输入框的内容与value属性值同步 无论什么情况，如果value的值如果直接被指定，则输入框的内容不可更改，如 当未设置onChange函数时，只有当设置为null或者undefined或者是变量的话才可更改；当设置onChange函数时，value设置为变量也可更改 texarea： 不再使用文本元素作为子元素，而是和input一样使用value属性 &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; select：创建下拉列表标签 一般html写法 用selected表示选中 React写法 在根标签select中设置value，来体现选中的是哪个标签 可以通过multiple属性+value数组来实现多选 2.9 状态提升在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步 state。 优点：易于排查bug：当有问题组件出现时，可以检查其Props属性，并向上追溯到更新这个props的组件的方法，从而定位bug 2.10 组合与继承 包含关系 需求是当设计FancyBorder，其具体内部内容是动态的不确定的，需要留一个“洞”给他。而props中有一个特殊的属性children，可以自定义组件的子元素获取到，并进行对应操作渲染，如 本来如果要访问props.children的话，是得要在组件的属性中定义“children&#x3D;{… …}”，但是React将children独有了，将其值定义为组件间包裹的子组件，所以可以填充这个洞 而如果想要留多个洞的话，就直接在属性里面设置即可；即配置props，如何组件内部再获取props中对应的元素进行调用渲染，而不用像vue那样设置插槽啥的，如 2.extra React哲学创建react的小项目 将设计好的UI划分为组件层级 更具单一功能原则进行划分 设计静态代码 编写静态代码和添加交互功能应当分开，因为编写静态代码要写大量代码但是不用考虑过多细节；编写交互功能要考虑大量细节而不用写太多代码 编写静态代码不应当使用state，因为state是可更改的属性，且更改会重新触发页面渲染，所以仅应当在交互的时候使用 简单项目可以选择自上而下构建组件，复杂项目建议自下而上构建组件并带上测试 确定UI state的最小完整表示 首先确认当前程序需要哪些数据： 包含所有产品的原始列表 用户输入的搜索词 复选框是否选中的值 经过搜索筛选的产品列表 判断这些数据是否是state，判断标准如下 该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。 该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。 你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。 包含所有产品的原始列表是经由 props 传入的，所以它不是 state；搜索词和复选框的值应该是 state，因为它们随时间会发生改变且无法由其他数据计算而来；经过搜索筛选的产品列表不是 state，因为它的结果可以由产品的原始列表根据搜索词和复选框的选择计算出来。 判断得到的state有 用户输入的搜索词 复选框是否选中的值 确定state放置的位置 找到根据这个state渲染的所有组件 找到这些组件的共同所有者组件（在组件层级上高于所有需要这个state的组件） 该共同所有者组件或者比它层级高的组件拥有该state 如果没有合适的位置，那就新创一个组件来存放该state，并将其置于高于共同所有者组件的位置 实现数据回流 父组件设置处理方法， 子组件设置监听方法，当子组件的监听方法监听到事件发生后，通知父组件的处理方法进行执行，修改相应state，同时重新渲染父组件和其下的所有子组件 3. Hook3.1 Hook简介Hook是什么，Hook就是让我们在函数组件中也能够调用class中才有的React特性的方法，称作钩子 Hook需要引入： Hook 是什么？ Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。稍后我们将学习其他 Hook。 什么时候我会用 Hook？ 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。 3.2 使用 State HookState Hook相当于在函数组件中实现了class组件中能够定义状态的React特性 定义state 在class中，我们在constructor中通过this.state来配置初始的state；通过this.setState方法来修改state 在使用Hook的函数组件中，我们通过useState() 方法来定义一个state和修改state的方法 useState 需要哪些参数？ 唯一的参数就是初始 state。 useState 方法的返回值是什么？返回值为：当前 state 以及更新 state 的函数 示例写法：const [count, setCount] = useState(0); 通过数组解构函数获取变量初始值和修改数组值的方法 读取state 在class中，需要读取state，使用this.state.count 在函数中，需要读取state，直接用count 更新state 在class中 在函数中 3.3 使用Effect HookEffect Hook的作用实际上是在函数组件中实现class组件中的生命周期函数（componentDidMount、componentDidUpdate、componentWillUnmount） Effect Hook 使用示例 我们将函数传入useEffect()函数，其将再浏览器每一次渲染前重新执行（这意味着除了最开始的渲染，每次改变导致的更新，浏览器都会先清除上一次的副作用再重新调用effect函数），在页面挂载后执行副作用的函数； 我们可以在函数中设置返回值，这代表当前副作用的清除操作，其会在组件卸载的时候执行,因为浏览器每一次渲染都会执行清除操作，所以清除函数在每一次渲染时都会被调用 每一次重新渲染都要重新执行effect的原因在于：实现componentDidUpdate，因为重新渲染会导致一些组件内部属性发生改变，而effect中可能会定义有组件内容或者获取组件属性的方法，如果没有重新执行的话， Effect Hook的作用 可以使用多个Effect实现关注点分离：在class中，由于生命周期的不同，我们往往需要把相同逻辑的代码拆分到不同的生命周秋中，而不同逻辑的代码聚合到单一生命周期中，这使得代码可读性差以及违反了单一职责原则；而使用Effect Hook后，我们可以将相同逻辑的代码聚合到单一的Effect中，实现关注点分离 extra：问题记录1. forEach映射问题 问题描述 products是一个数组，其中前三项有值，后三项为undefined 调用数组的forEach方法后，取到的product理应是数组中一项即但是返回的是整个数组 解决： 因为一个数组是双层的，里面还嵌套这一个数组 forEach只展开一次，所以下面的数组是它的第一项，还是一个数组 为什么呢？因为你不清楚map和forEach的用法就瞎用啊！！ 1.1 map array.map((item,index,arr)=&gt;callback,this) 参数： 回调函数的参数 必须 item：数组中的单个元素 必须 index：当前元素的序号 arr：当前元素属于的数组对象 this： 返回值：其会返回一个由回调函数的返回值所组成的数组，而之前的代码是这么写的： 用了push方法相当于把这新的数组给压入newProducts，就形成了双重数组。。。。。简单的错debug两小时，服了 1.2 forEach用户与map基本相同 1、map速度比forEach快 2、map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组，只会对原数组直接进行修改，返回undefined 3、map因为返回数组所以可以链式操作，forEach不能 4, map里可以用return（return的是什么，相当于把数组中的这一项变为什么（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了） ,而forEach里用return不起作用，forEach不能用break，会直接报错 1.3 debug小结 在理清程序的运行顺序后，可以在开发者工具上设置断点并执行： 如图将从235行开始按序执行 可以在右侧监听数据变化： "},{"title":"第一篇文章","date":"2022-09-22T07:12:24.000Z","url":"/2022/09/22/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","categories":[["undefined",""]],"content":"这是标题"},{"title":"Hello World","date":"2022-09-22T04:50:50.206Z","url":"/2022/09/22/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]