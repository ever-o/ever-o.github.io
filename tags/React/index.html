<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>标签: React | YYN_Blog</title>
  <meta name="author" content="Sapphire" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="记录个人学习笔记，思路，经历">
<meta property="og:type" content="website">
<meta property="og:title" content="标签: React">
<meta property="og:url" content="https://ever-o.github.io/tags/React/index.html">
<meta property="og:site_name" content="YYN_Blog">
<meta property="og:description" content="记录个人学习笔记，思路，经历">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Sapphire">
<meta name="twitter:card" content="summary">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/banner.webp');
      }
    
    
  </style>
  
<meta name="generator" content="Hexo 6.3.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li>
                                            
                                                <a href="/">
                                            
                                                
                                                    <i class="fa fa-home"></i>
                                                
                                                首页
                                            </a>
                                            
                                        </li>
                                    
                                        <li>
                                            
                                                <a href="/archives/">
                                            
                                                
                                                    <i class="fa fa-file"></i>
                                                
                                                档案馆
                                            </a>
                                            
                                        </li>
                                    
                                        <li>
                                            
                                                <a href="/friends/">
                                            
                                                
                                                    <i class="fa fa-paw"></i>
                                                
                                                好伙伴
                                            </a>
                                            
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">YYN_Blog</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>YYN_Blog</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <!-- Breadcrumb for tag & category page -->

    <article class="kratos-hentry kratos-entry-border-new clearfix">
        <div class="kratos-breadcrumb">
            <a href="/">
                <i class="fa fa-home"></i>
            </a>
            <i class="fa fa-angle-right"></i>
            
                <a href="/tags/">
                    标签
                </a>
                <i class="fa fa-angle-right"></i>
                <a href="/tags/React">
                    React
                </a>
            
            
        </div>
    </article>




    
    
        <article itemscope itemtype="https://schema.org/Article">
            <div class="kratos-hentry kratos-post-inner clearfix index-post">
                
                <header class="kratos-entry-header">
                    <h1 class="text-center"><a class="kratos-entry-title" href="/2022/09/22/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="mainEntityOfPage"><span itemprop="name headline">React学习笔记</span></a></h1>
                    
                    <ul class="kratos-post-meta text-center">
                        <li>
                        <time datetime="2022-09-22T08:48:32.000Z" itemprop="datePublished">
                            <i class="fa fa-calendar"></i> 2022-09-22
                        </time>
                        </li>
                        
                        
                            <li>
                                <i class="fa fa-tags"></i>
                                <a class="tag-none-link" href="/tags/React/" rel="tag">React</a>
                            </li>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </ul>
                </header>
                <hr />
                <div class="kratos-post-content" itemprop="articleBody">
                    <h1 id="1-教程井字棋"><a href="#1-教程井字棋" class="headerlink" title="1. 教程井字棋"></a>1. 教程井字棋</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><p>react中是实现方式是通过js的继承，继承自React.conpoment，是<strong>React组件类</strong>,通过继承其能够实现以下几点</p>
<ul>
<li>子组件存在render方法，其使用JSX语法，能够返回一个html结构，从而能够被其他组件当成标签来使用，实现组件化<ul>
<li>其中如果要使用js语句的话，用<code>&#123;&#125;</code>括起来即可</li>
</ul>
</li>
<li>子组件可以访问this.props对象来获取父组件传递给自己的属性or方法</li>
<li>子组件可以自定义状态属性：this.state，并且保存在state中的属性发生改变后，子组件及子组件的子组件的render函数中定义的部分界面会重新渲染</li>
</ul>
<h2 id="1-2-加深理解"><a href="#1-2-加深理解" class="headerlink" title="1.2 加深理解"></a>1.2 加深理解</h2><p>下面以井字棋程序作为例子，其中有三个类：Square、Boar、Game</p>
<p>个人对于prop和state的工作原理的粗浅理解</p>
<ul>
<li>prop属性能够实现的原因<ul>
<li>父组件在调用子组件，会定义其属性，调用的形式是以标签的方式进行的，这个实际上是在创建一个子组件的实例对象（因为子组件是类），然后将属性最为参数传递给子组件</li>
<li>子类的构造函数中会首先将参数给super()方法，通过盗用构造函数的方式使得父类（React.conponent）的构造函数在子类的构造函数的其他语句执行前先执行（即将父类定义的一些每个实例所独有的属性，在子类上重新定义一次）</li>
<li>而这些属性中应当包括props属性，并且将传入的参数赋给了这个属性，因此才能在子组件的实例中通过<strong>this.props</strong>来访问父组件传递给子组件的参数</li>
<li>而这个可以直接通过函数组件来实现，因此如果只需要props而不需要state的话，实际上是不需要通过继承来实现组件的创建，而可以直接通过函数来定义，如<img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209171730681.png" alt="image-20220917173023563"></li>
</ul>
</li>
<li>state属性实现原因<ul>
<li>首先父类（React.conpoment）中应当存在一个state属性，子类中继承了这个属性并且能够对其进行修改</li>
<li>其次父类中应该还安排了一些方法来实现对这个属性的监听，使之一旦发生改变，就使得当前组件和其子组件的所有页面内容都重新渲染，实现数据动态改变</li>
</ul>
</li>
<li>render()<ul>
<li>个人感觉类似于 Vue中的template？</li>
</ul>
</li>
</ul>
<h2 id="1-3-父子组件通信的实现方式"><a href="#1-3-父子组件通信的实现方式" class="headerlink" title="1.3 父子组件通信的实现方式"></a>1.3 父子组件通信的实现方式</h2><p>在react中，父子组件通信主要是通过<strong>状态提升</strong>实现的</p>
<blockquote>
<p>父组件和子组件区分，A组件调用B组件，A是父组件，B是子组件</p>
</blockquote>
<p>状态提升具体指的是</p>
<ul>
<li>本来是B需要管理自己的state和A传给B的prop对象</li>
<li>而如果想要实现二者的数据通信，以及父组件A对子组件B的定义数据的统一管理的话，可以进行状态提升</li>
<li>具体来说，就是将子组件B的state中需要统一管理的数据，以数组的形式保存在父组件A中，然后A再通过prop属性，将B需要的特定属性传递给B，当B需要修改数据值时，可以通过：A将自己的方法传递给B，B通过调用A的方法来修改其state，从而修改原本属于自己的值的方式进行。</li>
<li>这样就实现了父组件对子组件数据的统一管理，以及数据通信</li>
</ul>
<h2 id="1-4-列表中的key"><a href="#1-4-列表中的key" class="headerlink" title="1.4 列表中的key"></a>1.4 列表中的key</h2><ul>
<li><p>列表中的key的作用</p>
<ul>
<li><p>react为了效率，在更新列表的时候，是不会把原来的每一个列表项全都删除然后重新渲染的，而是会判断更新后的列表和之前的列表有无重合部分，然后只更新重合部分以外的其他部分</p>
</li>
<li><p>而key的作用就是<strong>判断哪些是重合部分</strong>，然后来决定是否需要销毁还是新建还是不变</p>
<blockquote>
<p><code>key</code> 是 React 中一个特殊的保留属性（还有一个是 <code>ref</code>，拥有更高级的特性）。当 React 元素被创建出来的时候，React 会提取出 <code>key</code> 属性，然后把 key 直接存储在返回的元素上。虽然 <code>key</code> 看起来好像是 <code>props</code> 中的一个，但是你不能通过 <code>this.props.key</code> 来获取 <code>key</code>。React 会通过 <code>key</code> 来自动判断哪些组件需要更新。组件是不能访问到它的 <code>key</code> 的。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="2-React官方文档"><a href="#2-React官方文档" class="headerlink" title="2. React官方文档"></a>2. React官方文档</h1><h2 id="2-1-JSX"><a href="#2-1-JSX" class="headerlink" title="2.1 JSX"></a>2.1 JSX</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>上述语句就是JSX，是JavaScript的一个语法扩展</p>
<p>其中我们可以嵌入JS代码，用<code>&#123;&#125;</code>引用；也可以讲JSX作为一个表达式，可以作为参数或者返回值；可以为JSX代码中的标签加上属性，或者指定子标签</p>
<p>JSX最后实际上会被Babel转译成一个名为<code>React.createElement()</code>的函数调用，以下了两种代码等价</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;greeting&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello, world!</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//与上面的代码等价</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上React.createElement()创建了这样的对象</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这些对象成为<strong>react元素</strong>，描述了你希望在屏幕上能看到的内容，React通过读取这些对象来构建dom以及保持更新</p>
<h2 id="2-2-元素渲染"><a href="#2-2-元素渲染" class="headerlink" title="2.2 元素渲染"></a>2.2 元素渲染</h2><ul>
<li><p>将元素渲染为DOM</p>
<ul>
<li>想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 <a target="_blank" rel="noopener" href="https://react.docschina.org/docs/react-dom.html#render"><code>ReactDOM.render()</code></a>：</li>
<li><code>ReactDOM.render(element, document.getElementById(&#39;root&#39;));</code></li>
</ul>
<blockquote>
<p>现在的渲染方式好像变了？</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">Clock</span> <span class="attr">data</span>=<span class="string">&#123;new</span> <span class="attr">Date</span>()&#125;&gt;</span><span class="tag">&lt;/<span class="name">Clock</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>得这样子才行？？</p>
</blockquote>
</li>
<li><p>更新已经渲染的dom元素</p>
<ul>
<li>React元素是不可变对象，一旦创建就不能修i该其子元素或者属性，所以要更新DOM元素也就是UI的方式只能是覆盖，即创建一个全新的元素，将其传入<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/react-dom.html#render"><code>ReactDOM.render()</code></a>。</li>
</ul>
</li>
<li><p>React 只更新它需要更新的部分</p>
</li>
</ul>
<h2 id="2-3-组件-amp-props"><a href="#2-3-组件-amp-props" class="headerlink" title="2.3 组件&amp;props"></a>2.3 组件&amp;props</h2><ul>
<li><p>函数组件和class组件</p>
<ul>
<li><p>函数组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是一个有效的React组件，因为它接受唯一带有数据的props对象并返回一个react元素，本质上是js函数</p>
</li>
<li><p>class组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述两个组件时等效的</p>
</li>
<li><p>‘注意组件名必须以大写字母开头，因为小写字母开头的组件会被React视为原生DOM标签’</p>
</li>
</ul>
</li>
<li><p>渲染组件</p>
<ul>
<li>React元素不仅是DOM元素，也可以时自定义组件，如<br><code>const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;</code><br>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “<strong>props</strong>”。</li>
</ul>
</li>
<li><p>组合组件：组合起来的组件</p>
</li>
<li><p>提取组件，相当于使得组件抽象化，提取组件形成可复用的组件库</p>
</li>
<li><p>Props是只读的不可修改的</p>
</li>
</ul>
<h2 id="2-4-State-amp-生命周期"><a href="#2-4-State-amp-生命周期" class="headerlink" title="2.4 State &amp; 生命周期"></a>2.4 State &amp; 生命周期</h2><ul>
<li>state只有在class组件中才有，在函数组件中没有</li>
<li>state的赋值只能在constructor方法中进行，其他地方如果要进行修改的话得调用 <code>this.setState()</code>方法</li>
<li>state值更新的时候，其会动态渲染组件中用到state对应值的地方</li>
<li>state的数据是向下流动的，可以通过将state的数据作为props，传递给当前组件的子组件，实现数据交流<ul>
<li>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</li>
<li>如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</li>
</ul>
</li>
<li>生命周期：每个class组件都有自己的生命周期函数<ul>
<li>componentDidMount()：组件挂载</li>
<li>componentWillUnmount()：组件卸载</li>
<li>… …</li>
</ul>
</li>
</ul>
<h2 id="2-5-事件处理"><a href="#2-5-事件处理" class="headerlink" title="2.5 事件处理"></a>2.5 事件处理</h2><ul>
<li><p>事件处理中不能通过return false来取消默认行为，而是得显示地写出<br><code>e.preventDefault();</code>，如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ActionLink</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The link was clicked.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Click me</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前提：<strong>在 JavaScript 中，class 的方法默认不会<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a> <code>this</code></strong></p>
</li>
<li><p>所以如果我们要将class中的方法当作回调函数，传递给子组件的话，需要手动为其绑定<code>this</code>,一共有三种绑定方式</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Toggle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: !state.<span class="property">isToggleOn</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一种，如上，直接在构造函数通过bind函数将handClick方法的this属性绑定为当前类实例的this（这样才能在之后调用实例的setState）</p>
</li>
<li><p>第二种，在需要调用函数的地方采取箭头函数的形式，如</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">()=&gt;</span><span class="variable language_">this</span>.<span class="title function_">handleClick</span>()&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>这会自动为这个方法绑定当前实例的this</p>
<ul>
<li>但是这会导致回调函数传入子组件，会导致这些子组件每次都重新渲染，新增不必要的开销</li>
</ul>
</li>
<li><p>第三种，函数通过函数表达式的方式进行定义<img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209181710576.png" alt="image-20220918171023459"></p>
</li>
<li><p>建议采用第一种</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-6-条件渲染"><a href="#2-6-条件渲染" class="headerlink" title="2.6 条件渲染"></a>2.6 条件渲染</h2><ul>
<li>额</li>
<li>可以通过 if else、&amp;&amp;、三目，来决定渲染的或者返回的元素</li>
<li>可以返回null，但是组件的生命周期仍然生效</li>
</ul>
<h2 id="2-7-列表-amp-key"><a href="#2-7-列表-amp-key" class="headerlink" title="2.7 列表 &amp; key"></a>2.7 列表 &amp; key</h2><ul>
<li><p>在React中，将列表转化为元素，可以通过<code>map()</code>方法实现，如</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表项应当设置一个key属性，用于React高效渲染</p>
<ul>
<li>key属性不要求全局唯一，只要在兄弟节点处唯一即可</li>
<li>key属性应当在数组的上下文中，记住map映射的元素列表要设置一个key即可</li>
<li>key属性是无法被访问到的，如果要使用key属性保存的变量，请使用其他属性再保存一次、</li>
<li>key属性在未配置时，会使用每一个元素的索引当作key值，这样当数组元素顺序改变时，会导致key值混乱，从而使得性能down，所以不建议用索引当key值，最好用一组数据中各不相同的值来作为key值</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ListItem</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">// 正确！这里不需要指定 key：</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.value&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">NumberList</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.<span class="property">numbers</span>;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// 正确！key 应该在数组的上下文中被指定</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ListItem</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>              <span class="attr">value</span>=<span class="string">&#123;number&#125;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;listItems&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-8-表单"><a href="#2-8-表单" class="headerlink" title="2.8 表单"></a>2.8 表单</h2><p>受控组件：在React中，表单元素维护自己的状态并且保存在组件的state属性中，并且只能通过setstate方法来更新，React的state属性时表单元素的唯一数据源。渲染表单的React组件控制着用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素就叫做“受控组件”</p>
<ul>
<li>React中不存在v-model之类的绑定语句，需要动态绑定数据的话得自己实现，如：</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NameForm</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;提交的名字: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>);</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          名字:</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>input：用value表示输入框的内容，输入框的内容与value属性值同步</p>
<ul>
<li><p>无论什么情况，如果value的值如果直接被指定，则输入框的内容不可更改，如<img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209192030634.png" alt="image-20220919203016571"></p>
<p>当未设置onChange函数时，只有当设置为null或者undefined或者是变量的话才可更改；当设置onChange函数时，value设置为变量也可更改</p>
</li>
</ul>
</li>
<li><p>texarea：</p>
<ul>
<li>不再使用文本元素作为子元素，而是和input一样使用value属性</li>
<li><code>&lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</code></li>
</ul>
</li>
<li><p>select：创建下拉列表标签</p>
<ul>
<li>一般html写法<img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209192024647.png" alt="image-20220919202431586"><ul>
<li>用selected表示选中</li>
</ul>
</li>
<li>React写法<img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209192025999.png" alt="image-20220919202501938"><ul>
<li>在根标签select中设置value，来体现选中的是哪个标签</li>
<li>可以通过multiple属性+value数组来实现多选</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="2-9-状态提升"><a href="#2-9-状态提升" class="headerlink" title="2.9 状态提升"></a>2.9 状态提升</h2><p>在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以<strong>将它提升至这些组件的最近共同父组件中</strong>。你应当依靠<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/state-and-lifecycle.html#the-data-flows-down">自上而下的数据流</a>，而不是尝试在不同组件间同步 state。</p>
<ul>
<li>优点：易于排查bug：当有问题组件出现时，可以检查其Props属性，并向上追溯到更新这个props的组件的方法，从而定位bug</li>
</ul>
<h2 id="2-10-组合与继承"><a href="#2-10-组合与继承" class="headerlink" title="2.10 组合与继承"></a>2.10 组合与继承</h2><ol>
<li>包含关系</li>
</ol>
<p>需求是当设计FancyBorder，其具体内部内容是动态的不确定的，需要留一个“洞”给他。而props中有一个特殊的属性children，可以自定义组件的子元素获取到，并进行对应操作渲染，如<img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209192048659.png" alt="image-20220919204851586"></p>
<p><img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209192048392.png" alt="image-20220919204858329"></p>
<blockquote>
<p>本来如果要访问props.children的话，是得要在组件的属性中定义<br>“children&#x3D;{… …}”，但是React将children独有了，将其值定义为组件间包裹的子组件，所以可以填充这个洞</p>
</blockquote>
<p>而如果想要留多个洞的话，就直接在属性里面设置即可；即配置props，如何组件内部再获取props中对应的元素进行调用渲染，而不用像vue那样设置插槽啥的，如</p>
<p><img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209192053811.png" alt="image-20220919205352740"></p>
<h2 id="2-extra-React哲学"><a href="#2-extra-React哲学" class="headerlink" title="2.extra React哲学"></a>2.extra React哲学</h2><p>创建react的小项目</p>
<ol>
<li><p>将设计好的UI划分为组件层级</p>
<ol>
<li>更具单一功能原则进行划分</li>
</ol>
</li>
<li><p>设计静态代码</p>
<ol>
<li>编写静态代码和添加交互功能应当分开，因为编写静态代码要写大量代码但是不用考虑过多细节；编写交互功能要考虑大量细节而不用写太多代码</li>
<li>编写静态代码不应当使用<strong>state</strong>，因为state是可更改的属性，且更改会重新触发页面渲染，所以仅应当在交互的时候使用</li>
<li>简单项目可以选择自上而下构建组件，复杂项目建议自下而上构建组件并带上测试</li>
</ol>
</li>
<li><p>确定UI state的最小完整表示</p>
<ol>
<li><p>首先确认当前程序需要哪些数据：</p>
<ol>
<li>包含所有产品的原始列表</li>
<li>用户输入的搜索词</li>
<li>复选框是否选中的值</li>
<li>经过搜索筛选的产品列表</li>
</ol>
</li>
<li><p>判断这些数据是否是state，判断标准如下</p>
<ol>
<li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li>
<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li>
<li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li>
</ol>
<blockquote>
<p>包含所有产品的原始列表是经由 props 传入的，所以它不是 state；搜索词和复选框的值应该是 state，因为它们随时间会发生改变且无法由其他数据计算而来；经过搜索筛选的产品列表不是 state，因为它的结果可以由产品的原始列表根据搜索词和复选框的选择计算出来。</p>
</blockquote>
</li>
<li><p>判断得到的state有</p>
<ol>
<li>用户输入的搜索词</li>
<li>复选框是否选中的值</li>
</ol>
</li>
</ol>
</li>
<li><p>确定state放置的位置</p>
<ol>
<li>找到根据这个state渲染的所有组件</li>
<li>找到这些组件的共同所有者组件（在组件层级上高于所有需要这个state的组件）</li>
<li>该共同所有者组件或者比它层级高的组件拥有该state</li>
<li>如果没有合适的位置，那就新创一个组件来存放该state，并将其置于高于共同所有者组件的位置</li>
</ol>
</li>
<li><p>实现数据回流</p>
<ol>
<li>父组件设置处理方法， 子组件设置监听方法，当子组件的监听方法监听到事件发生后，通知父组件的处理方法进行执行，修改相应state，同时重新渲染父组件和其下的所有子组件</li>
</ol>
</li>
</ol>
<h1 id="3-Hook"><a href="#3-Hook" class="headerlink" title="3. Hook"></a>3. Hook</h1><h2 id="3-1-Hook简介"><a href="#3-1-Hook简介" class="headerlink" title="3.1 Hook简介"></a>3.1 Hook简介</h2><p>Hook是什么，Hook就是让我们在函数组件中也能够调用class中才有的React特性的方法，称作钩子</p>
<p>Hook需要引入：<img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209202316306.png" alt="image-20220920231606234"></p>
<p><strong>Hook 是什么？</strong> Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，<code>useState</code> 是允许你在 React 函数组件中添加 state 的 Hook。稍后我们将学习其他 Hook。</p>
<p><strong>什么时候我会用 Hook？</strong> 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。</p>
<h2 id="3-2-使用-State-Hook"><a href="#3-2-使用-State-Hook" class="headerlink" title="3.2 使用 State Hook"></a>3.2 使用 State Hook</h2><p>State Hook相当于在函数组件中实现了class组件中能够<strong>定义状态</strong>的React特性</p>
<p>定义state</p>
<ul>
<li>在class中，我们在constructor中通过this.state来配置初始的state；通过this.setState方法来修改state</li>
<li>在使用Hook的函数组件中，我们通过<code>useState()</code> 方法来定义一个state和修改state的方法<ul>
<li><strong><code>useState</code> 需要哪些参数？</strong> 唯一的参数就是初始 state。</li>
<li><strong><code>useState</code> 方法的返回值是什么？</strong>返回值为：当前 state 以及更新 state 的函数</li>
<li>示例写法：<code>const [count, setCount] = useState(0);</code><ul>
<li>通过数组解构函数获取变量初始值和修改数组值的方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>读取state</p>
<ul>
<li><p>在class中，需要读取state，使用this.state.count</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;<span class="title class_">You</span> clicked &#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>&#125; times&lt;/p&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在函数中，需要读取state，直接用count</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;<span class="title class_">You</span> clicked &#123;count&#125; times&lt;/p&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>更新state</p>
<ul>
<li><p>在class中</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button </span><br><span class="line">  onClick=&#123;<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;)&#125;&gt;   </span><br><span class="line"><span class="title class_">Click</span> me</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在函数中</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">setCount</span>(count + <span class="number">1</span>)&#125;&gt; </span><br><span class="line">  <span class="title class_">Click</span> me</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-3-使用Effect-Hook"><a href="#3-3-使用Effect-Hook" class="headerlink" title="3.3 使用Effect Hook"></a>3.3 使用Effect Hook</h2><p>Effect Hook的作用实际上是在函数组件中实现class组件中的生命周期函数（componentDidMount、componentDidUpdate、componentWillUnmount）</p>
<p>Effect Hook 使用示例</p>
<p><img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209211156729.png" alt="image-20220921115602593"></p>
<p><img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209211156075.png" alt="image-20220921115618011"></p>
<ul>
<li>我们将函数传入useEffect()函数，其将再浏览器<strong>每一次</strong>渲染前重新执行（这意味着除了最开始的渲染，每次改变导致的更新，浏览器都会先清除上一次的副作用再重新调用effect函数），在页面挂载后执行副作用的函数；</li>
<li>我们可以在函数中设置返回值，这代表当前副作用的<strong>清除操作</strong>，其会在组件卸载的时候执行,因为浏览器每一次渲染都会执行清除操作，所以清除函数在每一次渲染时都会被调用<ul>
<li>每一次重新渲染都要重新执行effect的原因在于：实现componentDidUpdate，因为重新渲染会导致一些组件内部属性发生改变，而effect中可能会定义有组件内容或者获取组件属性的方法，如果没有重新执行的话，</li>
</ul>
</li>
<li>Effect Hook的作用<ul>
<li>可以使用多个Effect实现关注点分离：在class中，由于生命周期的不同，我们往往需要把相同逻辑的代码拆分到不同的生命周秋中，而不同逻辑的代码聚合到单一生命周期中，这使得代码可读性差以及违反了单一职责原则；而使用Effect Hook后，我们可以将相同逻辑的代码聚合到单一的Effect中，实现关注点分离</li>
</ul>
</li>
</ul>
<h1 id="extra：问题记录"><a href="#extra：问题记录" class="headerlink" title="extra：问题记录"></a>extra：问题记录</h1><h2 id="1-forEach映射问题"><a href="#1-forEach映射问题" class="headerlink" title="1. forEach映射问题"></a>1. forEach映射问题</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> products = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">products</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;products is&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(products)</span><br><span class="line"><span class="keyword">const</span> empty = []</span><br><span class="line">products.<span class="title function_">forEach</span>(<span class="function">(<span class="params">product</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (product) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;curProduct is &quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(product)</span><br><span class="line">        <span class="keyword">if</span> (product.<span class="property">category</span> !== curCategory) &#123;</span><br><span class="line">            rows.<span class="title function_">push</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ProductCategoryRow</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">category</span>=<span class="string">&#123;product.category&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">key</span>=<span class="string">&#123;product.category&#125;/</span>&gt;</span></span>)</span><br><span class="line">        &#125;</span><br><span class="line">        rows.<span class="title function_">push</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">ProductRow</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">product</span>=<span class="string">&#123;product&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">key</span>=<span class="string">&#123;product.name&#125;/</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">        curCategory = product.<span class="property">category</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209202208893.png" alt="image-20220920220804770"></p>
<ul>
<li>问题描述<ul>
<li>products是一个数组，其中前三项有值，后三项为undefined</li>
<li>调用数组的forEach方法后，取到的product理应是数组中一项即但是返回的是整个数组</li>
</ul>
</li>
<li>解决：<ul>
<li>因为一个数组是双层的，里面还嵌套这一个数组</li>
<li>forEach只展开一次，所以下面的数组是它的第一项，还是一个数组</li>
</ul>
</li>
<li>为什么呢？因为你不清楚map和forEach的用法就瞎用啊！！</li>
</ul>
<h3 id="1-1-map"><a href="#1-1-map" class="headerlink" title="1.1 map"></a>1.1 map</h3><p> <code>array.map((item,index,arr)=&gt;callback,this)</code></p>
<ul>
<li><p>参数：</p>
<ul>
<li>回调函数的参数 必须<ul>
<li>item：数组中的单个元素 必须</li>
<li>index：当前元素的序号</li>
<li>arr：当前元素属于的数组对象</li>
</ul>
</li>
<li>this：</li>
<li><img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209202232381.png" alt="image-20220920223246309"></li>
</ul>
</li>
<li><p>返回值：其会返回一个由回调函数的返回值所组成的<strong>数组</strong>，而之前的代码是这么写的：</p>
</li>
<li><pre><code class="jsx">newProducts.push(curProducts.map((product)=&gt;&#123;
    if (product.name.indexOf(filterText) !== -1) &#123;
        return product;
    &#125;
&#125;))
</code></pre>
<p>用了push方法相当于把这新的<strong>数组</strong>给压入newProducts，就形成了双重数组。。。。。简单的错debug两小时，服了</p>
</li>
</ul>
<h3 id="1-2-forEach"><a href="#1-2-forEach" class="headerlink" title="1.2 forEach"></a>1.2 forEach</h3><p>用户与map基本相同</p>
<p>1、map速度比forEach快</p>
<p>2、<strong>map会返回一个新数组</strong>，不对原数组产生影响,<strong>foreach</strong>不会产生新数组，只<strong>会对原数组直接进行修改</strong>，返回undefined</p>
<p>3、map因为返回数组所以可以<strong>链式操作</strong>，forEach不能</p>
<p>4, map里可以用return（return的是什么，相当于把数组中的这一项变为什么（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了） ,而forEach里用return不起作用，forEach不能用break，会直接报错</p>
<h3 id="1-3-debug小结"><a href="#1-3-debug小结" class="headerlink" title="1.3 debug小结"></a>1.3 debug小结</h3><ul>
<li>在理清程序的运行顺序后，可以在开发者工具上设置断点并执行：<img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209202242257.png" alt="image-20220920224243152"><ul>
<li>如图将从235行开始按序执行</li>
</ul>
</li>
<li>可以在右侧监听数据变化：<img src="https://typaro-img.oss-cn-nanjing.aliyuncs.com/typaroImg/202209202243215.png" alt="image-20220920224336135"></li>
</ul>

                </div>
                <footer class="kratos-entry-footer clearfix">
                    <div class="post-like-donate text-center clearfix">
                        <a class="read-more" href="/2022/09/22/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" title="React学习笔记">继续阅读 <i class="fa fa-chevron-circle-right"></i></a>
                    </div>
                </footer>
            </div>
        </article>
    





    <div class="hidden">
        <!-- 加载文章阅读对应的统计功能，评论自带的那种 -->
        
    </div>



        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
        <div class="sticky-area">
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">记录个人学习笔记，思路，经历</p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                4
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                0
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                1
            </span>
        </a>
    </div>
</aside>
            
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/React/" style="font-size: 0.6em;">React</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/09/23/JavaScript%E5%AD%A6%E4%B9%A0/"><i class="fa  fa-book"></i> JavaScript学习</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/09/22/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><i class="fa  fa-book"></i> React学习笔记</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/09/22/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"><i class="fa  fa-book"></i> 第一篇文章</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/09/22/hello-world/"><i class="fa  fa-book"></i> Hello World</a>
            
          
        
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/CandyUnion"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="me" href="https://nya.one/@Candinya"><i class="fa fa fa-share-alt-square"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/Candinya"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 YYN_Blog 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by Sapphire.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/false.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/vendors/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>